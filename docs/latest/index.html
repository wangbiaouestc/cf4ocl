<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>cf4ocl (C Framework for OpenCL): Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-42378595-1', 'auto');
  ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cf4ocl (C Framework for OpenCL)
   &#160;<span id="projectnumber">v2.0.0+1.43478a0</span>
   </div>
   <div id="projectbrief">Object-oriented framework for developing and benchmarking OpenCL projects in C/C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">cf4ocl (C Framework for OpenCL) Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ug_overview">Overview</a><ul><li class="level2"><a href="#ug_features">Features</a></li>
</ul>
</li>
<li class="level1"><a href="#ug_libray">Using the library</a><ul><li class="level2"><a href="#ug_basics">Basics</a><ul><li class="level3"><a href="#ug_forg">Library organization</a></li>
<li class="level3"><a href="#ug_new_destroy">The new/destroy rule</a></li>
<li class="level3"><a href="#ug_getinfo">Getting info about OpenCL objects</a></li>
<li class="level3"><a href="#ug_errorhandle">Error handling</a></li>
<li class="level3"><a href="#ug_log">Log messages</a></li>
</ul>
</li>
<li class="level2"><a href="#ug_wrappers">Wrapper modules</a><ul><li class="level3"><a href="#ug_platform">Platform module</a></li>
<li class="level3"><a href="#ug_device">Device module</a></li>
<li class="level3"><a href="#ug_context">Context module</a></li>
<li class="level3"><a href="#ug_queue">Command queue module</a></li>
<li class="level3"><a href="#ug_memobj">Memory object module</a></li>
<li class="level3"><a href="#ug_buffer">Buffer module</a></li>
<li class="level3"><a href="#ug_image">Image module</a></li>
<li class="level3"><a href="#ug_sampler">Sampler module</a></li>
<li class="level3"><a href="#ug_program">Program module</a></li>
<li class="level3"><a href="#ug_kernel">Kernel module</a><ul><li class="level4"><a href="#ug_kernel_args">Kernel arguments module</a></li>
</ul>
</li>
<li class="level3"><a href="#ug_event">Event module</a><ul><li class="level4"><a href="#ug_event_wait_lists">Event wait lists module</a></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><a href="#ug_othermodules">Other modules</a><ul><li class="level3"><a href="#ug_devsel">Device selector module</a></li>
<li class="level3"><a href="#ug_devquery">Device query module</a></li>
<li class="level3"><a href="#ug_errors">Errors module</a></li>
<li class="level3"><a href="#ug_platforms">Platforms module</a></li>
<li class="level3"><a href="#ug_profiling">Profiler module</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#ug_utils">Using the utilities</a><ul><li class="level2"><a href="#ug_devinfo">ccl_devinfo program</a></li>
<li class="level2"><a href="#ug_kerninfo">ccl_kerninfo program</a></li>
<li class="level2"><a href="#ug_plot_events">ccl_plot_events.py script</a></li>
</ul>
</li>
<li class="level1"><a href="#ug_advanced">Advanced</a><ul><li class="level2"><a href="#ug_architecture">Wrapper architecture</a></li>
<li class="level2"><a href="#ug_cclwrapper">The CCLWrapper base class</a></li>
<li class="level2"><a href="#ug_ccldevcontainer">The CCLDevContainer class</a></li>
<li class="level2"><a href="#ug_cclmemobj">The CCLMemObj class</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><em>cf4ocl</em> user guide.</p>
<h1><a class="anchor" id="ug_overview"></a>
Overview</h1>
<p>The C Framework for OpenCL, <em>cf4ocl</em>, is a cross-platform pure C object-oriented framework for developing and benchmarking <a href="http://www.khronos.org/opencl/">OpenCL</a> projects in C. It aims to:</p>
<ol type="1">
<li>Promote the rapid development of OpenCL programs in C, with support for C++.</li>
<li>Assist in the benchmarking of OpenCL events, such as kernel execution and data transfers.</li>
<li>Simplify the analysis of the OpenCL environment and of kernel requirements.</li>
</ol>
<h2><a class="anchor" id="ug_features"></a>
Features</h2>
<ul>
<li>Object-oriented interface to the OpenCL API<ul>
<li>New/destroy functions, no direct memory alloc/free</li>
<li>Easy (and extensible) device selection</li>
<li>Simple event dependency mechanism</li>
<li>User-friendly error management</li>
</ul>
</li>
<li>OpenCL version independent</li>
<li>Integrated profiling</li>
</ul>
<h1><a class="anchor" id="ug_libray"></a>
Using the library</h1>
<h2><a class="anchor" id="ug_basics"></a>
Basics</h2>
<h3><a class="anchor" id="ug_forg"></a>
Library organization</h3>
<p>The <em>cf4ocl</em> library offers an object-oriented interface to the OpenCL API using wrapper classes and methods (or structs and functions, in C terms), grouped into modules of the same name, as shown in the following table:</p>
<table class="doxtable">
<tr>
<th><em>cf4ocl</em> module </th><th><em>cf4ocl</em> wrapper class </th><th>Wrapped OpenCL type  </th></tr>
<tr>
<td><a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html">Platform module</a> </td><td><a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#gad5b2427c1c3565977ebf05a9536d84b8" title="Platform wrapper class. ">CCLPlatform</a>* </td><td>cl_platform_id </td></tr>
<tr>
<td><a class="el" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html">Device module</a> </td><td><a class="el" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#gaa18648559193d4a248b1b81e3fcc56f7" title="Device wrapper class. ">CCLDevice</a>* </td><td>cl_device_id </td></tr>
<tr>
<td><a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html">Context module</a> </td><td><a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga8bf8e21eb589f02f25064e4869c8b8df" title="Context wrapper class. ">CCLContext</a>* </td><td>cl_context </td></tr>
<tr>
<td><a class="el" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html">Queue module</a> </td><td><a class="el" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#ga961b7c1f3a0e7bb4fef88401b9f11714" title="Command queue wrapper class. ">CCLQueue</a>* </td><td>cl_command_queue </td></tr>
<tr>
<td><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html">Program module</a> </td><td><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gad49948bcbb49fc6dbd83928775f8cb33" title="Program wrapper class. ">CCLProgram</a>* </td><td>cl_program </td></tr>
<tr>
<td><a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html">Kernel module</a> </td><td><a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga55709ccabc636d6afabb41dd4d9ab277" title="Kernel wrapper class. ">CCLKernel</a>* </td><td>cl_kernel </td></tr>
<tr>
<td><a class="el" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html">Event module</a> </td><td><a class="el" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html#ga615bf932ba8b81cc25ce8fcbaf3006a1" title="Event wrapper class. ">CCLEvent</a>* </td><td>cl_event </td></tr>
<tr>
<td><a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html">MemObj module</a> </td><td><a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html#gaaad489261449960e89631f7e1cb8706d" title="Base class for memory object wrappers, i.e., CCLBuffer and CCLImage. ">CCLMemObj</a>* </td><td>cl_mem </td></tr>
<tr>
<td><a class="el" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html">Buffer module</a> </td><td><a class="el" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html#ga74a5e095bf96ac7f6ebb99bbb61a926f" title="Buffer wrapper class. ">CCLBuffer</a>* </td><td>cl_mem </td></tr>
<tr>
<td><a class="el" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html">Image module</a> </td><td><a class="el" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga0aac60cad56cb1a8cd89d138d8d5acd2" title="Image wrapper class. ">CCLImage</a>* </td><td>cl_mem </td></tr>
<tr>
<td><a class="el" href="group___c_c_l___s_a_m_p_l_e_r___w_r_a_p_p_e_r.html">Sampler module</a> </td><td><a class="el" href="group___c_c_l___s_a_m_p_l_e_r___w_r_a_p_p_e_r.html#ga23ebcd4de2b4e4142cd62c337886c133" title="Sampler wrapper class. ">CCLSampler</a>* </td><td>cl_sampler </td></tr>
</table>
<p>Some of the provided methods directly wrap OpenCL functions (e.g. <a class="el" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html#ga372c55d1591155b2e79576f82f9a4a0f" title="Copy from one buffer object to another. ">ccl_buffer_enqueue_copy()</a>), while others perform a number of OpenCL operations in one function call (e.g. <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gacdf010f28f7c6f22b68a780a6fcfc59c" title="Set kernel arguments and enqueue it for execution on a device. ">ccl_kernel_set_args_and_enqueue_ndrange()</a>). The wrapper classes are organized in a hierarchical <a class="el" href="index.html#ug_architecture">inheritance tree</a>.</p>
<p>Additional modules are also available:</p>
<table class="doxtable">
<tr>
<th><em>cf4ocl</em> module </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html">Device selector module</a> </td><td>Automatically select devices using filters. </td></tr>
<tr>
<td><a class="el" href="group___c_c_l___d_e_v_i_c_e___q_u_e_r_y.html">Device query module</a> </td><td>Helpers for querying device information, mainly used by the <a class="el" href="index.html#ug_devinfo">ccl_devinfo</a> program. </td></tr>
<tr>
<td><a class="el" href="group___c_c_l___e_r_r_o_r_s.html">Errors module</a> </td><td>Convert OpenCL error codes into human-readable strings. </td></tr>
<tr>
<td><a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m_s.html">Platforms module</a> </td><td>Management of the OpencL platforms available in the system. </td></tr>
<tr>
<td><a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html">Profiler module</a> </td><td>Simple, convenient and thorough profiling of OpenCL events. </td></tr>
</table>
<h3><a class="anchor" id="ug_new_destroy"></a>
The new/destroy rule</h3>
<p>The <em>cf4ocl</em> constructors and destructors have <code>new</code> and <code>destroy</code> in their name, respectively. In <em>cf4ocl</em>, the new/destroy rule states the following:</p>
<p><em>For each invoked constructor, the respective destructor must also be invoked.</em></p>
<p>This might seem obvious, but in many instances several objects are obtained using other (non-constructor) methods during the course of a program. These objects are automatically released and should not be destroyed by client code.</p>
<p>For example, it is possible to get a kernel belonging to a program using the <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga4784ac5e69352e4425ab26e92e68e683" title="Get the kernel wrapper object for the given program kernel function. ">ccl_program_get_kernel()</a> function:</p>
<div class="fragment"><div class="line"><a class="code" href="structccl__program.html">CCLProgram</a>* prg;</div>
<div class="line"><a class="code" href="structccl__kernel.html">CCLKernel</a>* krnl;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">prg = <a class="code" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga9a9844b053aa5e871c5f3955844ac13a">ccl_program_new_from_source_file</a>(ctx, <span class="stringliteral">&quot;myprog.cl&quot;</span>, NULL);</div>
</div><!-- fragment --> <div class="fragment"><div class="line">krnl = <a class="code" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga4784ac5e69352e4425ab26e92e68e683">ccl_program_get_kernel</a>(prg, <span class="stringliteral">&quot;someKernel&quot;</span>, NULL);</div>
</div><!-- fragment --><p>The returned kernel wrapper object will be freed when the program is destroyed; as such, there is no need to free it. Destroying the program will suffice:</p>
<div class="fragment"><div class="line"><a class="code" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga3e96ea5591aaa0635ddfd24854845c4a">ccl_program_destroy</a>(prg);</div>
</div><!-- fragment --><h3><a class="anchor" id="ug_getinfo"></a>
Getting info about OpenCL objects</h3>
<p>The <code>ccl_&lt;class&gt;_get_info_&lt;scalar|array&gt;()</code> macros can be used to get information about OpenCL objects. Use the <code>array</code> version when the expected return value is a pointer or array, or the <code>scalar</code> version otherwise (e.g. when the expected return value is primitive or scalar type).</p>
<p>For example, to get the name and the number of compute cores on a device:</p>
<div class="fragment"><div class="line"><a class="code" href="structccl__device.html">CCLDevice</a>* dev;</div>
<div class="line"><span class="keywordtype">char</span>* name;</div>
<div class="line">cl_uint n_cores;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">name = <a class="code" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#ga61ad09b46b5dd633b3fe3a6df6a8ee8a">ccl_device_get_info_array</a>(dev, CL_DEVICE_NAME, <span class="keywordtype">char</span>*, NULL);</div>
<div class="line">n_cores = <a class="code" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#ga22cde1f14be27178324e6abf2ababd63">ccl_device_get_info_scalar</a>(dev, CL_DEVICE_MAX_COMPUTE_UNITS, cl_uint, NULL);</div>
</div><!-- fragment --><p>The <code>ccl_&lt;class&gt;_get_info()</code> macros serve more specific scenarios, and are likely to be used less often. These macros return a <a class="el" href="ccl__abstract__wrapper_8h.html#a1613a2eb5dac5a1287594a09c7b36c02" title="Class which represents information about a wrapped OpenCL object. ">CCLWrapperInfo</a>* object, which contains two public fields:</p>
<ul>
<li><code>value</code> - A pointer to the requested value as returned by the OpenCL <code>clGet*Info()</code> functions.</li>
<li><code>size</code> - The size in bytes of the value pointed to by the <code>value</code> field.</li>
</ul>
<p>To use the value, a cast should be performed on the <code>value</code> field to convert it to the required type (which is what the <code>ccl_&lt;class&gt;_get_info_&lt;scalar|array&gt;()</code> macros automatically do).</p>
<p>The values and objects returned by these macros are automatically released when the respective wrapper object is destroyed and should never be directly freed by client code.</p>
<h3><a class="anchor" id="ug_errorhandle"></a>
Error handling</h3>
<p>Error-reporting <em>cf4ocl</em> functions provide two methods for client-side error handling:</p>
<ol type="1">
<li>The return value.</li>
<li><a href="https://developer.gnome.org/glib/stable/glib-Error-Reporting.html#GError">GError</a>-based error-reporting.</li>
</ol>
<p>The first method consists of analysing the return value of a function. Error-throwing functions which return a pointer will return <code>NULL</code> if an error occurs. The remaining error-reporting functions return <code>CL_FALSE</code> if an error occurs (or <code>CL_TRUE</code> otherwise). Client code can check for errors by looking for <code>NULL</code> or <code>CL_FALSE</code> return values, depending on the function. This error handling method does not provide additional information about the reported error. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="structccl__context.html">CCLContext</a>* ctx;</div>
<div class="line"><a class="code" href="structccl__program.html">CCLProgram</a>* prg;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">prg = <a class="code" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga9a9844b053aa5e871c5f3955844ac13a">ccl_program_new_from_source_file</a>(ctx, <span class="stringliteral">&quot;program.cl&quot;</span>, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (!prg) {</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;An error ocurred&quot;</span>);</div>
<div class="line">    exit(-1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The second method uses the <a href="https://developer.gnome.org/glib/stable/glib-Error-Reporting.html">GLib Error Reporting</a> approach and is more flexible. A <code>GError</code> object is initialized to <code>NULL</code>, and a pointer to it is passed as the last argument to the function being called. If the <code>GError</code> object is still <code>NULL</code> after the function call, no error has occurred. Otherwise, an error occurred and it is possible to get a user-friendly error message:</p>
<div class="fragment"><div class="line"><a class="code" href="structccl__context.html">CCLContext</a>* ctx;</div>
<div class="line"><a class="code" href="structccl__program.html">CCLProgram</a>* prg;</div>
<div class="line">GError* err = NULL;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">prg = <a class="code" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga9a9844b053aa5e871c5f3955844ac13a">ccl_program_new_from_source_file</a>(ctx, <span class="stringliteral">&quot;program.cl&quot;</span>, &amp;err);</div>
<div class="line"><span class="keywordflow">if</span> (err) {</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;%s&quot;</span>, err-&gt;message);</div>
<div class="line">    exit(-1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>An error domain and error code are also available in the <code>GError</code> object. The domain indicates the module the error-reporting function is located in, while the code indicates the specific error that occurred. Three kinds of domain can be returned by error-reporting <em>cf4ocl</em> functions, each of them associated with distinct error codes:</p>
<table class="doxtable">
<tr>
<th>Domain </th><th>Codes </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="ccl__common_8h.html#a528bf687affd4a6f04b0a1b6f2acf96d" title="Resolves to error category identifying string, in this case an error in cf4ocl. ">CCL_ERROR</a> </td><td><a class="el" href="ccl__common_8h.html#a16432a86b11701820bd8e4b5ea307b95" title="Error codes. ">ccl_error_code</a> enum </td><td>Error in <em>cf4ocl</em> not related with external libraries </td></tr>
<tr>
<td><a class="el" href="ccl__common_8h.html#ab6baf75b8ff2a93da86e10a150dc28ed" title="Resolves to error category identifying string, in this case an error in the OpenCL library...">CCL_OCL_ERROR</a> </td><td><a href="http://www.khronos.org/registry/cl/api/2.0/cl.h">cl.h</a> </td><td>Error in OpenCL function calls </td></tr>
<tr>
<td>A GLib domain </td><td><a href="https://developer.gnome.org/glib/stable/">GLib-module</a> dependent </td><td>Error in GLib function call (file open/save, etc) </td></tr>
</table>
<p>For example, it is possible for client code to act on different OpenCL errors:</p>
<div class="fragment"><div class="line"><a class="code" href="structccl__context.html">CCLContext</a>* ctx;</div>
<div class="line"><a class="code" href="structccl__buffer.html">CCLBuffer</a>* buf;</div>
<div class="line">GError* err = NULL;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">buf = <a class="code" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html#gaad3ceccbfd37a726e5deb8b088c21273">ccl_buffer_new</a>(ctx, flags, size, host_ptr, &amp;err);</div>
<div class="line"><span class="keywordflow">if</span> (err) {</div>
<div class="line">    <span class="keywordflow">if</span> (err-&gt;domain == <a class="code" href="ccl__common_8h.html#ab6baf75b8ff2a93da86e10a150dc28ed">CCL_OCL_ERROR</a>) {</div>
<div class="line">        <span class="comment">/* Check if it&#39;s OpenCL error. */</span></div>
<div class="line">        <span class="keywordflow">switch</span> (err-&gt;code) {</div>
<div class="line">            <span class="comment">/* Do different things depending on OpenCL error code. */</span></div>
<div class="line">            <span class="keywordflow">case</span> CL_INVALID_VALUE:</div>
<div class="line">                <span class="comment">/* Handle invalid values */</span></div>
<div class="line">            <span class="keywordflow">case</span> CL_INVALID_BUFFER_SIZE:</div>
<div class="line">                <span class="comment">/* Handle invalid buffer sizes */</span></div>
<div class="line">            <span class="keywordflow">case</span> CL_INVALID_HOST_PTR:</div>
<div class="line">                <span class="comment">/* Handle invalid host pointer */</span></div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Handle other OpenCL errors */</span></div>
<div class="line"></div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">/* Handle other errors */</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally, if client code wants to continue execution after an error was caught, it is mandatory to use the <a href="https://developer.gnome.org/glib/stable/glib-Error-Reporting.html#g-clear-error">g_clear_error()</a> function to free the error object and reset its value to <code>NULL</code>. Not doing so is a bug, especially if more error-reporting functions are to be called moving forward. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="structccl__context.html">CCLContext</a>* ctx;</div>
<div class="line"><a class="code" href="structccl__program.html">CCLProgram</a>* prg;</div>
<div class="line">GError* err = NULL;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">prg = <a class="code" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga9a9844b053aa5e871c5f3955844ac13a">ccl_program_new_from_source_file</a>(ctx, <span class="stringliteral">&quot;program.cl&quot;</span>, &amp;err);</div>
<div class="line"><span class="keywordflow">if</span> (err) {</div>
<div class="line">    <span class="comment">/* Print the error message, but don&#39;t terminate program. */</span></div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;%s&quot;</span>, err-&gt;message);</div>
<div class="line">    g_clear_error(&amp;err);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Even if the program terminates due to an error, the <a href="https://developer.gnome.org/glib/stable/glib-Error-Reporting.html#g-clear-error">g_clear_error()</a> function can be still be called to destroy the error object.</p>
<h3><a class="anchor" id="ug_log"></a>
Log messages</h3>
<p><em>cf4ocl</em> uses the <a href="https://developer.gnome.org/glib/stable/glib-Message-Logging.html">GLib message logging framework</a> to log messages and warnings. <em>cf4ocl</em> log output is handled by <a href="https://developer.gnome.org/glib/stable/glib-Message-Logging.html#g-log-default-handler">GLib's default log handler</a>, which outputs warnings and messages to <code>stderr</code>. If client code wishes to redirect this output, it can do so by specifying another <a href="https://developer.gnome.org/glib/stable/glib-Message-Logging.html#GLogFunc">log function</a> for the <code>cf4ocl2</code> log domain with <a href="https://developer.gnome.org/glib/stable/glib-Message-Logging.html#g-log-set-handler">g_log_set_handler()</a>. For example:</p>
<div class="fragment"><div class="line"><span class="comment">/* Log function which outputs messages to a stream specified in user_data. */</span></div>
<div class="line"><span class="keywordtype">void</span> my_log_function(<span class="keyword">const</span> gchar *log_domain, GLogLevelFlags log_level,</div>
<div class="line">    <span class="keyword">const</span> gchar *message, gpointer user_data) {</div>
<div class="line"></div>
<div class="line">    g_fprintf((FILE*) user_data, <span class="stringliteral">&quot;[%s](%d)&gt;%s\n&quot;</span>,</div>
<div class="line">        log_domain, log_level, message);</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">FILE* my_file;</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">/* Add log handler for all messages from cf4ocl. */</span></div>
<div class="line">g_log_set_handler(<span class="stringliteral">&quot;cf4ocl2&quot;</span>, G_LOG_LEVEL_MASK | G_LOG_FLAG_FATAL | G_LOG_FLAG_RECURSION,</div>
<div class="line">    my_log_function, my_file);</div>
</div><!-- fragment --><h2><a class="anchor" id="ug_wrappers"></a>
Wrapper modules</h2>
<p>Each <a href="http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/classDiagram.html">OpenCL class</a> is associated with a <em>cf4ocl</em> module. At the most basic level, each module offers a wrapper class and functions which wrap or map their OpenCL equivalents. This, in itself, already simplifies working with OpenCL in C, because the <em>cf4ocl</em> wrapper classes internally manages directly related objects, which may be created during the course of a program. As such, client code just needs to follow the <a class="el" href="index.html#ug_new_destroy">new/destroy</a> rule for directly created objects, thus not having to worry with memory allocation/deallocation of intermediate objects.</p>
<p>In most cases, however, each <em>cf4ocl</em> module also provides methods for other common and not-so-common OpenCL host code patterns, allowing the programmer to avoid their verbosity and focus on OpenCL device code.</p>
<p>All <em>cf4ocl</em> wrapper classes extend the <a class="el" href="ccl__common_8h.html#adfe76120dcae2bab1547887f101051e7" title="Base class for all OpenCL wrappers. ">CCLWrapper</a>* abstract wrapper class. The properties and methods of this class, which are concerned with reference counts, wrapping/unwrapping of OpenCL objects and getting object information, are essentially of internal use by other <em>cf4ocl</em> classes. This functionality is also available to client code which requires a more advanced integration with <em>cf4ocl</em>, as explained in the <a class="el" href="index.html#ug_cclwrapper">advanced</a> section.</p>
<p>Several OpenCL objects, namely <code>cl_platform_id</code>, <code>cl_context</code> and <code>cl_program</code>, have a direct relationship with a set of <code>cl_device_id</code> objects. In order to map this relationship, <em>cf4ocl</em> provides the <a class="el" href="ccl__common_8h.html#af08e755467d7fb60b52685e2c21752e0" title="Base class for wrappers which contain devices, i.e., CCLPlatform, CCLProgram and CCLContext. ">CCLDevContainer</a>* class, which is an intermediate class between the <a class="el" href="ccl__common_8h.html#adfe76120dcae2bab1547887f101051e7" title="Base class for all OpenCL wrappers. ">CCLWrapper</a>* parent class and the <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#gad5b2427c1c3565977ebf05a9536d84b8" title="Platform wrapper class. ">CCLPlatform</a>*, <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga8bf8e21eb589f02f25064e4869c8b8df" title="Context wrapper class. ">CCLContext</a>* and <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gad49948bcbb49fc6dbd83928775f8cb33" title="Program wrapper class. ">CCLProgram</a>* wrappers. The <a class="el" href="ccl__common_8h.html#af08e755467d7fb60b52685e2c21752e0" title="Base class for wrappers which contain devices, i.e., CCLPlatform, CCLProgram and CCLContext. ">CCLDevContainer</a>* class implements functionality for managing a set of <a class="el" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#gaa18648559193d4a248b1b81e3fcc56f7" title="Device wrapper class. ">CCLDevice</a>* wrapper instances. This functionality is exposed to client code through concrete wrapper methods. For example, the <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga8bf8e21eb589f02f25064e4869c8b8df" title="Context wrapper class. ">CCLContext</a>* class provides the <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#gaf8acdf97580810c5b1daede0daa62c91" title="Get all device wrappers in context. ">ccl_context_get_all_devices()</a>, <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga7b425787d8bdd23e88ff4f8242ac94c7" title="Get CCLDevice wrapper at given index. ">ccl_context_get_device()</a> and <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga24bb321d56a70861575ac627a5f35b97" title="Return number of devices in context. ">ccl_context_get_num_devices()</a> methods for this purpose.</p>
<h3><a class="anchor" id="ug_platform"></a>
Platform module</h3>
<p>The platform wrapper module provides functionality for simple handling of OpenCL platform objects. Platform wrappers can be obtain in two ways:</p>
<ol type="1">
<li>From a given <a class="el" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#gaa18648559193d4a248b1b81e3fcc56f7" title="Device wrapper class. ">CCLDevice</a>* device wrapper, using the <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#ga5db25cfd6924435f7456015e089de085" title="Get the platform wrapper for the given device wrapper. ">ccl_platform_new_from_device()</a> function (in which case, the object must be destroyed with <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#gabe467e223cca70dadb5fb5618d8e3898" title="Decrements the reference count of the platform wrapper object. ">ccl_platform_destroy()</a>, following the <em>cf4ocl</em> <a class="el" href="index.html#ug_new_destroy">new/destroy</a> rule).</li>
<li>From a <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m_s.html#ga6ca8d1882c5b73479018698ce535f2cc" title="Class which represents the OpenCL platforms available in the system. ">CCLPlatforms</a>* object (which contains the list of platforms in the system), using the <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m_s.html#gaaae2cba6bd1625e3a60293725a21af47" title="Get platform wrapper object at given index. ">ccl_platforms_get()</a> function. In this case the platform wrapper is automatically destroyed when the <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m_s.html#ga6ca8d1882c5b73479018698ce535f2cc" title="Class which represents the OpenCL platforms available in the system. ">CCLPlatforms</a>* object is freed; as such, client code should not directly destroy the platform wrapper. See the <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m_s.html">platforms module</a> for more details.</li>
</ol>
<p>The provided functions allow to get the device wrappers associated with the given platform wrapper, as well as to obtain the supported OpenCL version of the underlying OpenCL platform object.</p>
<p>Information about platform objects can be fetched using the platform <a class="el" href="index.html#ug_getinfo">info macros</a>:</p>
<ul>
<li><a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#ga916c6eb16417f112b5ff093665279c96" title="Macro which returns a scalar platform information value. ">ccl_platform_get_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#gadc821ec09e0c7f2a361d622861bd7097" title="Macro which returns an array platform information value. ">ccl_platform_get_info_array()</a></li>
<li><a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#ga135f353f7902af330acb0d222f0c1c47" title="Get a CCLWrapperInfo platform information object. ">ccl_platform_get_info()</a></li>
</ul>
<p>However, because the platform info return type is always <code>char*</code>, <em>cf4ocl</em> provides an additional helper macro for platform wrappers, <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#ga50e81021f7f653dd18334c124fde820c" title="Helper macro which gets a platform information string. ">ccl_platform_get_info_string()</a>, which is simpler to use.</p>
<p>The <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#gad5b2427c1c3565977ebf05a9536d84b8" title="Platform wrapper class. ">CCLPlatform</a>* class extends the <a class="el" href="ccl__common_8h.html#af08e755467d7fb60b52685e2c21752e0" title="Base class for wrappers which contain devices, i.e., CCLPlatform, CCLProgram and CCLContext. ">CCLDevContainer</a>* class; as such, it provides methods for handling a list of devices associated with the platform:</p>
<ul>
<li><a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#ga60e51d79d998c3df40e7568541805ca9" title="Get all device wrappers in platform. ">ccl_platform_get_all_devices()</a></li>
<li><a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#ga479d80428a613e5af69fab3cef95e6f4" title="Get CCLDevice wrapper at given index. ">ccl_platform_get_device()</a></li>
<li><a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#gacad1914ef2758580a0b7fe2a4be4e429" title="Return number of devices in platform. ">ccl_platform_get_num_devices()</a></li>
</ul>
<p><em>Usage example:</em></p>
<div class="fragment"><div class="line"><a class="code" href="structccl__platform.html">CCLPlatform</a>* platf;</div>
<div class="line"><a class="code" href="structccl__device.html">CCLDevice</a>* dev;</div>
<div class="line"><span class="keywordtype">char</span>* platf_name;</div>
<div class="line">cl_uint platf_ver;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">platf = <a class="code" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#ga5db25cfd6924435f7456015e089de085">ccl_platform_new_from_device</a>(dev, NULL);</div>
</div><!-- fragment --> <div class="fragment"><div class="line">platf_name =</div>
<div class="line">    <a class="code" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#ga50e81021f7f653dd18334c124fde820c">ccl_platform_get_info_string</a>(platf, CL_PLATFORM_NAME, NULL);</div>
</div><!-- fragment --> <div class="fragment"><div class="line">platf_ver = <a class="code" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#ga9790282ef2da0dd35a98efe300adb035">ccl_platform_get_opencl_version</a>(platf, NULL);</div>
</div><!-- fragment --> <div class="fragment"><div class="line">printf(<span class="stringliteral">&quot;Platform name is %s\n: &quot;</span>, platf_name);</div>
<div class="line">printf(<span class="stringliteral">&quot;Platform version is %f\n: &quot;</span>, platf_ver / 100.0f);</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a class="code" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#gabe467e223cca70dadb5fb5618d8e3898">ccl_platform_destroy</a>(platf);</div>
</div><!-- fragment --><h3><a class="anchor" id="ug_device"></a>
Device module</h3>
<p>The device wrapper module provides functionality for simple handling of OpenCL device objects. In most cases, device wrapper objects should not be directly instanced by client code. They are usually fetched from <a class="el" href="ccl__common_8h.html#af08e755467d7fb60b52685e2c21752e0">device container</a> objects such as <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#gad5b2427c1c3565977ebf05a9536d84b8" title="Platform wrapper class. ">CCLPlatform</a>* or <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga8bf8e21eb589f02f25064e4869c8b8df" title="Context wrapper class. ">CCLContext</a>* instances, or created as sub-devices using the <a class="el" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#ga396c4215822044abe872c31f50bd98dc" title="Creates a NULL-terminated array of sub-devices that each reference a non-intersecting set of compute ...">ccl_device_create_subdevices()</a> function. In either case, when the parent object is destroyed, the associated devices (or sub-devices) are also destroyed. As such, and in accordance with the <em>cf4ocl</em> <a class="el" href="index.html#ug_new_destroy">new/destroy</a> rule, the <a class="el" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#gadc25b3af05ba91550c08a4d7c1064332" title="Decrements the reference count of the device wrapper object. ">ccl_device_destroy()</a> destructor function will rarely be used.</p>
<p>Information about device objects can be fetched using the device <a class="el" href="index.html#ug_getinfo">info macros</a>:</p>
<ul>
<li><a class="el" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#ga22cde1f14be27178324e6abf2ababd63" title="Macro which returns a scalar device information value. ">ccl_device_get_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#ga61ad09b46b5dd633b3fe3a6df6a8ee8a" title="Macro which returns an array device information value. ">ccl_device_get_info_array()</a></li>
<li><a class="el" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#ga9776d949048d4e4129a0f669d27ef2eb" title="Get a CCLWrapperInfo device information object. ">ccl_device_get_info()</a></li>
</ul>
<p><em>Example: getting the first device in a context</em></p>
<div class="fragment"><div class="line"><a class="code" href="structccl__context.html">CCLContext</a>* ctx;</div>
<div class="line"><a class="code" href="structccl__device.html">CCLDevice</a>* dev;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">dev = <a class="code" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga7b425787d8bdd23e88ff4f8242ac94c7">ccl_context_get_device</a>(ctx, 0, NULL);</div>
</div><!-- fragment --><h3><a class="anchor" id="ug_context"></a>
Context module</h3>
<p>The context wrapper module provides functionality for simple handling of OpenCL context objects. Context wrappers can be created using three different approaches:</p>
<ol type="1">
<li>From a list of <a class="el" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#gaa18648559193d4a248b1b81e3fcc56f7" title="Device wrapper class. ">CCLDevice</a>* device wrappers, using the <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#gafc53fae5e0966a84ff49185ddc5957ff" title="Creates a context wrapper given an array of CCLDevice wrappers and the remaining parameters required ...">ccl_context_new_from_devices_full()</a> function or the <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga6aec28f859612d01edbdaf2a5621d46e" title="Creates a context wrapper given an array of CCLDevice wrappers. ">ccl_context_new_from_devices()</a> macro. This is the approach usually followed when using the <a href="http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/clCreateContext.html">clCreateContext()</a> OpenCL function directly.</li>
<li>From a list of <a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga910386a6aac4f278e79b32118bd3cc14" title="A set of independent and dependent device filters. ">CCLDevSelFilters</a>* device filters, using the <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga3d8c995ca400c45b976f95b00481918f" title="Create a new context wrapper object selecting devices using the given set of filters. ">ccl_context_new_from_filters_full()</a> function or the <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#gae774ea8a5ce7e99d8f9de7d41f16bf2c" title="Create a new context wrapper object selecting devices using the given set of filters. ">ccl_context_new_from_filters()</a> macro. This is a very flexible mechanism, which is explained in detail in the <a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html">device selection module</a> section.</li>
<li>Using one of the several convenience constructors, which contain predefined filters, such as <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga3b7da887486c6842d683666fc1839b09" title="Creates a context wrapper for a GPU device. ">ccl_context_new_gpu()</a>, <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga71e2ed11e126b868f6754a3e29079265" title="Creates a context wrapper for the first found device(s). ">ccl_context_new_any()</a> or <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga8e9832d88b1db2432c8694a64f911289" title="Creates a context wrapper from a device selected by the user from a menu. ">ccl_context_new_from_menu()</a>.</li>
</ol>
<p>Instantiation and destruction of context wrappers follows the <em>cf4ocl</em> <a class="el" href="index.html#ug_new_destroy">new/destroy</a> rule; as such, context wrapper objects must be released with the <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga098e2247761d601377556cd26e1e28ba" title="Decrements the reference count of the context wrapper object. ">ccl_context_destroy()</a> function.</p>
<p>Information about context objects can be fetched using the context <a class="el" href="index.html#ug_getinfo">info macros</a>:</p>
<ul>
<li><a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#gaa2869f6efad7cc40b845bba0e7948456" title="Macro which returns a scalar context information value. ">ccl_context_get_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga3302bcfd33c4afcdf78e49fdef2dcb86" title="Macro which returns an array context information value. ">ccl_context_get_info_array()</a></li>
<li><a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga722352bc3d24e41cde8483876fa3a0da" title="Get a CCLWrapperInfo context information object. ">ccl_context_get_info()</a></li>
</ul>
<p>The <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga8bf8e21eb589f02f25064e4869c8b8df" title="Context wrapper class. ">CCLContext</a>* class extends the <a class="el" href="ccl__common_8h.html#af08e755467d7fb60b52685e2c21752e0" title="Base class for wrappers which contain devices, i.e., CCLPlatform, CCLProgram and CCLContext. ">CCLDevContainer</a>* class; as such, it provides methods for handling a list of devices associated with the context:</p>
<ul>
<li><a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#gaf8acdf97580810c5b1daede0daa62c91" title="Get all device wrappers in context. ">ccl_context_get_all_devices()</a></li>
<li><a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga7b425787d8bdd23e88ff4f8242ac94c7" title="Get CCLDevice wrapper at given index. ">ccl_context_get_device()</a></li>
<li><a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga24bb321d56a70861575ac627a5f35b97" title="Return number of devices in context. ">ccl_context_get_num_devices()</a></li>
</ul>
<p><em>Example: using all devices in a platform</em></p>
<div class="fragment"><div class="line"><a class="code" href="structccl__platform.html">CCLPlatform</a>* platf;</div>
<div class="line"><a class="code" href="structccl__context.html">CCLContext</a>* ctx;</div>
<div class="line"><span class="keyword">const</span>* <a class="code" href="structccl__device.html">CCLDevice</a>* devs;</div>
<div class="line">cl_uint num_devs;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">devs = <a class="code" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#ga60e51d79d998c3df40e7568541805ca9">ccl_platform_get_all_devices</a>(platf, NULL);</div>
<div class="line">num_devs = <a class="code" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#gacad1914ef2758580a0b7fe2a4be4e429">ccl_platform_get_num_devices</a>(platf, NULL);</div>
</div><!-- fragment --> <div class="fragment"><div class="line">ctx = <a class="code" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga6aec28f859612d01edbdaf2a5621d46e">ccl_context_new_from_devices</a>(num_devs, devs, NULL);</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a class="code" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga098e2247761d601377556cd26e1e28ba">ccl_context_destroy</a>(ctx);</div>
</div><!-- fragment --><p><em>Example: select device from menu</em></p>
<div class="fragment"><div class="line"><a class="code" href="structccl__context.html">CCLContext</a>* ctx;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">ctx = <a class="code" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga8e9832d88b1db2432c8694a64f911289">ccl_context_new_from_menu</a>(NULL);</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a class="code" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga098e2247761d601377556cd26e1e28ba">ccl_context_destroy</a>(ctx);</div>
</div><!-- fragment --><h3><a class="anchor" id="ug_queue"></a>
Command queue module</h3>
<p>The command queue wrapper module provides functionality for simple handling of OpenCL command queue objects. Queue wrappers can be instantiated with the <a class="el" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#ga19d744607a66062c9c4073d483c19773" title="Create a new on-host command queue wrapper object. ">ccl_queue_new()</a> and <a class="el" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#ga4ba1e3096cd2b7a6f6c652669016a847" title="Create a new on-host command queue wrapper object. ">ccl_queue_new_full()</a> constructors. While both constructors can be used with any OpenCL version, the later is targeted for OpenCL 2.0, exposing OpenCL 2.0 features, such as on-device queues, to client code. If "OpenCL 2.0 only" features are requested for platforms with OpenCL version &lt;= 2.0, a warning will be logged and the queue will be created without the unsupported features.</p>
<p>Instantiation and destruction of queue wrappers follows the <em>cf4ocl</em> <a class="el" href="index.html#ug_new_destroy">new/destroy</a> rule; as such, queues should be freed with the <a class="el" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#gaa2059bbd0f34d0dbc2f618e57f283993" title="Decrements the reference count of the command queue wrapper object. ">ccl_queue_destroy()</a> destructor.</p>
<p>Queue wrappers created with the <code>CL_QUEUE_PROFILING_ENABLE</code> property can be automatically profiled with the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html">profiler module</a>.</p>
<p>Information about queue objects can be fetched using the <a class="el" href="index.html#ug_getinfo">info macros</a>:</p>
<ul>
<li><a class="el" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#ga7e1863aa812b539311614c84f0252b21" title="Macro which returns a scalar command queue information value. ">ccl_queue_get_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#ga97b8b9990dfbc46e8392fcdf940386df" title="Macro which returns an array command queue information value. ">ccl_queue_get_info_array()</a></li>
<li><a class="el" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#gaade28513a86db999a135b7e669495eae" title="Get a CCLWrapperInfo command queue information object. ">ccl_queue_get_info()</a></li>
</ul>
<p><em>Example:</em></p>
 <div class="fragment"><div class="line">    <span class="comment">/* Wrappers for OpenCL objects. */</span></div>
<div class="line">    <a class="code" href="structccl__queue.html">CCLQueue</a>* queue;</div>
<div class="line">    <span class="comment">/* Error handling object (must be initialized to NULL). */</span></div>
<div class="line">    GError* err = NULL;</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Create a command queue. */</span></div>
<div class="line">    queue = <a class="code" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#ga19d744607a66062c9c4073d483c19773">ccl_queue_new</a>(ctx, dev, 0, &amp;err);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Release wrappers. */</span></div>
<div class="line">    <a class="code" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#gaa2059bbd0f34d0dbc2f618e57f283993">ccl_queue_destroy</a>(queue);</div>
</div><!-- fragment --></p>
<h3><a class="anchor" id="ug_memobj"></a>
Memory object module</h3>
<p>The memory object wrapper module provides functionality for simple handling of generic OpenCL memory objects. All the functions in this module are direct wrappers of the respective OpenCL memory object functions, except for the <a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html#ga705c61b225d7b9bd1c5d6ef770f09a28" title="Get the OpenCL version of the platform associated with this memory object. ">ccl_memobj_get_opencl_version()</a> function, which returns the OpenCL version of the platform to which the memory object is associated with.</p>
<p>For specific buffer and image handling, see the <a class="el" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html">buffer wrapper</a> and <a class="el" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html">image wrapper</a> modules.</p>
<p>Information about memory objects can be fetched using the memory object <a class="el" href="index.html#ug_getinfo">info macros</a>:</p>
<ul>
<li><a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html#ga109ee9a6c19fea73f4aaa6f35cf35a71" title="Macro which returns a scalar memory object information value. ">ccl_memobj_get_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html#gaf80fecd20061b3e8a9380f28c2bace3d" title="Macro which returns an array memory object information value. ">ccl_memobj_get_info_array()</a></li>
<li><a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html#ga1a1b97511228d56896d63062adc54ac2" title="Get a CCLWrapperInfo memory object information object. ">ccl_memobj_get_info()</a></li>
</ul>
<h3><a class="anchor" id="ug_buffer"></a>
Buffer module</h3>
<p>The buffer wrapper module provides functionality for simple handling of OpenCL buffer objects. All the functions in this module are direct wrappers of the respective OpenCL buffer functions, except for the <a class="el" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html#ga03265a441f7c1b054045706679de22fd" title="Creates a sub-buffer that represents a specific region in the given buffer. ">ccl_buffer_new_from_region()</a> function. This function wraps <a href="http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/clCreateSubBuffer.html">clCreateSubBuffer()</a> but assumes that the sub-buffer will represent a specific region in the original buffer (which is the only sub-buffer type, up to OpenCL 2.0).</p>
<p>Buffer wrapper objects can be directly passed as kernel arguments to functions such as <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gacdf010f28f7c6f22b68a780a6fcfc59c" title="Set kernel arguments and enqueue it for execution on a device. ">ccl_kernel_set_args_and_enqueue_ndrange()</a> or <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga7729c9cf1fb0601601efca8d55bfbf9c" title="Set all kernel arguments. ">ccl_kernel_set_args_v()</a>.</p>
<p>Information about buffer objects can be fetched using the <a class="el" href="index.html#ug_getinfo">info macros</a> from the <a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html">memory object module</a>:</p>
<ul>
<li><a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html#ga109ee9a6c19fea73f4aaa6f35cf35a71" title="Macro which returns a scalar memory object information value. ">ccl_memobj_get_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html#gaf80fecd20061b3e8a9380f28c2bace3d" title="Macro which returns an array memory object information value. ">ccl_memobj_get_info_array()</a></li>
<li><a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html#ga1a1b97511228d56896d63062adc54ac2" title="Get a CCLWrapperInfo memory object information object. ">ccl_memobj_get_info()</a></li>
</ul>
<p>Instantiation and destruction of buffer wrappers follows the <em>cf4ocl</em> <a class="el" href="index.html#ug_new_destroy">new/destroy</a> rule.</p>
<p><em>Example:</em></p>
<div class="fragment"><div class="line"><a class="code" href="structccl__buffer.html">CCLBuffer</a>* buf;</div>
<div class="line">cl_float host_data[BSIZE];</div>
<div class="line"><span class="keywordtype">size_t</span> buf_size = BSIZE * <span class="keyword">sizeof</span>(cl_float);</div>
</div><!-- fragment --><div class="fragment"><div class="line">buf = <a class="code" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html#gaad3ceccbfd37a726e5deb8b088c21273">ccl_buffer_new</a>(</div>
<div class="line">    context, CL_MEM_READ_WRITE, buf_size, NULL, NULL);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html#ga35233c6c927a2304d81ce149a2de673c">ccl_buffer_enqueue_write</a>(queue, buf, CL_TRUE, 0, buf_size,</div>
<div class="line">    host_data, NULL, NULL);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html#ga4399e6ec33872f78ece3e011f8e59ff6">ccl_buffer_enqueue_read</a>(queue, buf, CL_TRUE, 0, buf_size,</div>
<div class="line">    host_data, NULL, NULL);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html#gae761eec2e3606f68832925a2ffc8f49b">ccl_buffer_destroy</a>(buf);</div>
</div><!-- fragment --><h3><a class="anchor" id="ug_image"></a>
Image module</h3>
<p>The image wrapper module provides functionality for simple handling of OpenCL image objects. All the functions in this module are direct wrappers of the respective OpenCL image functions. The <a class="el" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#gabf3130507f0a4dbcb3a54e5ff13621df" title="Creates a new image wrapper object using a variable list of key-value pairs which describe the image...">ccl_image_new()</a> constructor accepts a variable list of arguments which describe the image to be created. There is also the <a class="el" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#gac0d22c672245ade3846c746162889659" title="Creates a new image wrapper object. ">ccl_image_new_v()</a>, which accepts the image description arguments given in a <a class="el" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga0612b87f3c5d135d350a658a115dacb3" title="Describes the type and dimensions of the image or image array independently of the OpenCL version...">CCLImageDesc</a>* object. Both constructors will automatically use the old style <a href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateImage2D.html">clCreateImage2D()</a>/<a href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateImage3D.html">clCreateImage3D()</a> constructors if the underlying platform OpenCL version is less or equal than 1.1, or the new <a href="http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/clCreateImage.html">clCreateImage()</a> constructor otherwise. Instantiation and destruction of image wrappers follows the <em>cf4ocl</em> <a class="el" href="index.html#ug_new_destroy">new/destroy</a> rule; as such, images should be freed with the <a class="el" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga6b44461736e02c3d6fd1b1c1545f98a3" title="Decrements the reference count of the wrapper object. ">ccl_image_destroy()</a> destructor.</p>
<p>Image wrapper objects can be directly passed as kernel arguments to functions such as <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gabdf0fff525612aeb22304560e4ea3bce" title="Enqueues a program kernel function for execution on a device. ">ccl_program_enqueue_kernel()</a> or <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga4508866d747b73309735ac56ba8d0c03" title="Set one kernel argument. ">ccl_kernel_set_arg()</a>.</p>
<p>Information about image objects can be fetched using the image <a class="el" href="index.html#ug_getinfo">info macros</a>:</p>
<ul>
<li><a class="el" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#gadc7fdcbf4bc51c5f44e04269239b6740" title="Macro which returns a scalar image information value. ">ccl_image_get_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga7ae12ecfba03e935e933a91b0ef77ef7" title="Macro which returns an array image information value. ">ccl_image_get_info_array()</a></li>
<li><a class="el" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga1922d5494993c1b648fd936e7fd93787" title="Get a CCLWrapperInfo image information object. ">ccl_image_get_info()</a></li>
</ul>
<p>If the information to be fetched is relative to the memory object parent class (e.g. <code>CL_MEM_TYPE</code> or <code>CL_MEM_FLAGS</code>), then the <a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html">memory object module</a> info macros should be used instead:</p>
<ul>
<li><a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html#ga109ee9a6c19fea73f4aaa6f35cf35a71" title="Macro which returns a scalar memory object information value. ">ccl_memobj_get_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html#gaf80fecd20061b3e8a9380f28c2bace3d" title="Macro which returns an array memory object information value. ">ccl_memobj_get_info_array()</a></li>
<li><a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html#ga1a1b97511228d56896d63062adc54ac2" title="Get a CCLWrapperInfo memory object information object. ">ccl_memobj_get_info()</a></li>
</ul>
<p><em>Example:</em></p>
<div class="fragment"><div class="line"><a class="code" href="structccl__queue.html">CCLQueue</a>* queue;</div>
<div class="line"><a class="code" href="structccl__image.html">CCLImage</a>* img_in;</div>
<div class="line"><a class="code" href="structccl__image.html">CCLImage</a>* img_out;</div>
<div class="line">cl_uchar4 host_img[IMG_X * IMG_Y];</div>
<div class="line">cl_image_format image_format = { CL_RGBA, CL_UNSIGNED_INT8 };</div>
<div class="line"><span class="keywordtype">size_t</span> origin[3] = { 0, 0, 0 };</div>
<div class="line"><span class="keywordtype">size_t</span> region[3] = { IMG_X, IMG_Y, 1 };</div>
</div><!-- fragment --> <div class="fragment"><div class="line">img_in = <a class="code" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#gabf3130507f0a4dbcb3a54e5ff13621df">ccl_image_new</a>(ctx, CL_MEM_READ_ONLY, &amp;image_format, NULL, &amp;err,</div>
<div class="line">    <span class="stringliteral">&quot;image_type&quot;</span>, (cl_mem_object_type) CL_MEM_OBJECT_IMAGE2D,</div>
<div class="line">    <span class="stringliteral">&quot;image_width&quot;</span>, (<span class="keywordtype">size_t</span>) IMG_X,</div>
<div class="line">    <span class="stringliteral">&quot;image_height&quot;</span>, (<span class="keywordtype">size_t</span>) IMG_Y,</div>
<div class="line">    NULL);</div>
<div class="line">img_out = <a class="code" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#gabf3130507f0a4dbcb3a54e5ff13621df">ccl_image_new</a>(ctx, CL_MEM_WRITE_ONLY, &amp;image_format, NULL, &amp;err,</div>
<div class="line">    <span class="stringliteral">&quot;image_type&quot;</span>, (cl_mem_object_type) CL_MEM_OBJECT_IMAGE2D,</div>
<div class="line">    <span class="stringliteral">&quot;image_width&quot;</span>, (<span class="keywordtype">size_t</span>) IMG_X,</div>
<div class="line">    <span class="stringliteral">&quot;image_height&quot;</span>, (<span class="keywordtype">size_t</span>) IMG_Y,</div>
<div class="line">    NULL);</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a class="code" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga26d4b539acd98fd9ae91711436875700">ccl_image_enqueue_write</a>(queue, img_in, CL_TRUE, origin, region,</div>
<div class="line">    0, 0, host_img, NULL, NULL);</div>
</div><!-- fragment --><p> <em>enqueue some image processing kernel...</em> </p><div class="fragment"><div class="line"><a class="code" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga58ed359a08c3f017a9482e214813c8a3">ccl_image_enqueue_read</a>(queue, img_out, CL_TRUE, origin, region,</div>
<div class="line">    0, 0, host_img, NULL, NULL);</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a class="code" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga6b44461736e02c3d6fd1b1c1545f98a3">ccl_image_destroy</a>(img_in);</div>
<div class="line"><a class="code" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga6b44461736e02c3d6fd1b1c1545f98a3">ccl_image_destroy</a>(img_out);</div>
</div><!-- fragment --><h3><a class="anchor" id="ug_sampler"></a>
Sampler module</h3>
<p>The sampler wrapper module provides functionality for simple handling of OpenCL sampler objects. Sampler wrapper objects can be instanced with two constructors:</p>
<ul>
<li><a class="el" href="group___c_c_l___s_a_m_p_l_e_r___w_r_a_p_p_e_r.html#gab155be86761780e830397afa80ab69b4" title="Create a new sampler wrapper object by specifying a basic set of sampler properties. ">ccl_sampler_new()</a></li>
<li><a class="el" href="group___c_c_l___s_a_m_p_l_e_r___w_r_a_p_p_e_r.html#ga72b865ab8176bf23e17cc4a570eec474" title="Create a new sampler wrapper object using a list of properties. ">ccl_sampler_new_full()</a></li>
</ul>
<p>The former follows the constructor format in OpenCL 1.0-1.2, where three main sampler properties are directly given as constructor arguments, namely the normalized coordinates flag, the addressing mode and the filter mode. The later uses the OpenCL 2.0 constructor format, in which sampler properties are given in a zero-terminated array of <code>cl_sampler_properties</code>. Both formats can be used without concern for the underlying platform's OpenCL version, because <em>cf4ocl</em> will automatically select the most adequate OpenCL constructor.</p>
<p>Sampler wrapper objects should be freed with the <a class="el" href="group___c_c_l___s_a_m_p_l_e_r___w_r_a_p_p_e_r.html#ga0cfa8939d808d2bf3a0c932498547c1a" title="Decrements the reference count of the wrapper object. ">ccl_sampler_destroy()</a> function, in accordance with the <em>cf4ocl</em> <a class="el" href="index.html#ug_new_destroy">new/destroy</a> rule.</p>
<p>Sampler wrapper objects can be directly passed as kernel arguments to functions such as <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gacdf010f28f7c6f22b68a780a6fcfc59c" title="Set kernel arguments and enqueue it for execution on a device. ">ccl_kernel_set_args_and_enqueue_ndrange()</a> or <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gaff6fc17690d0ad1517ad71c5405e4aff" title="Set all kernel arguments. ">ccl_kernel_set_args()</a>.</p>
<p>Information about sampler objects can be fetched using the sampler <a class="el" href="index.html#ug_getinfo">info macros</a>:</p>
<ul>
<li><a class="el" href="group___c_c_l___s_a_m_p_l_e_r___w_r_a_p_p_e_r.html#gaa62aa09863cb475a4de8703587370856" title="Macro which returns a scalar sampler information value. ">ccl_sampler_get_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___s_a_m_p_l_e_r___w_r_a_p_p_e_r.html#gaf767141334411a1716cebafd7f71c7df" title="Macro which returns an array sampler information value. ">ccl_sampler_get_info_array()</a></li>
<li><a class="el" href="group___c_c_l___s_a_m_p_l_e_r___w_r_a_p_p_e_r.html#ga0f683839761fe9828e551751129fdfaa" title="Get a CCLWrapperInfo sampler information object. ">ccl_sampler_get_info()</a></li>
</ul>
<p><em>Example:</em></p>
 <div class="fragment"><div class="line">    <a class="code" href="structccl__context.html">CCLContext</a>* ctx;</div>
<div class="line">    <a class="code" href="structccl__sampler.html">CCLSampler</a>* smplr;</div>
<div class="line">    GError* err = NULL;</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    smplr = <a class="code" href="group___c_c_l___s_a_m_p_l_e_r___w_r_a_p_p_e_r.html#gab155be86761780e830397afa80ab69b4">ccl_sampler_new</a>(ctx, CL_FALSE, CL_ADDRESS_CLAMP_TO_EDGE,</div>
<div class="line">        CL_FILTER_NEAREST, &amp;err);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <a class="code" href="group___c_c_l___s_a_m_p_l_e_r___w_r_a_p_p_e_r.html#ga0cfa8939d808d2bf3a0c932498547c1a">ccl_sampler_destroy</a>(smplr);</div>
</div><!-- fragment --></p>
<h3><a class="anchor" id="ug_program"></a>
Program module</h3>
<p>The program wrapper module provides functionality for simple handling of OpenCL program objects. OpenCL program objects can be created from source code, from binary data or from built-in kernels using the <a href="http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/clCreateProgramWithSource.html">clCreateProgramWithSource()</a>, <a href="http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/clCreateProgramWithBinary.html">clCreateProgramWithBinary()</a> or <a href="http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/clCreateProgramWithBuiltInKernels.html">clCreateProgramWithBuiltInKernels()</a>, respectively (the later requires OpenCL &gt;= 1.2). <em>cf4ocl</em> provides a set of <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gad49948bcbb49fc6dbd83928775f8cb33" title="Program wrapper class. ">CCLProgram</a>* program wrapper constructors which not only map the native OpenCL program constructors, but also extend some of their functionality.</p>
<p>For creating programs from source code, <em>cf4ocl</em> provides the following constructors:</p>
<ul>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga9a9844b053aa5e871c5f3955844ac13a" title="Create a new program wrapper object from a source file. ">ccl_program_new_from_source_file()</a> - Create a new program wrapper object from a source file.</li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga401588208985578fa812043b9d0983f7" title="Create a new program wrapper object from several source files. ">ccl_program_new_from_source_files()</a> - Create a new program wrapper object from several source files.</li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga96ffc087b78c9f4995b19cd837407531" title="Create a new program wrapper object from a null-terminated source string. ">ccl_program_new_from_source()</a> - Create a new program wrapper object from a null-terminated source string.</li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga96bb474dd20cc84ca95aee76041509dc" title="Create a new program wrapper object from several source code strings. ">ccl_program_new_from_sources()</a> - Create a new program wrapper object from several source code strings.</li>
</ul>
<p>Program constructors which use binary data follow the same pattern as their source code counterparts:</p>
<ul>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga42a35003af92a7ae458232b0b668f143" title="Create a new program wrapper object from a file containing binary code executable on a specific devic...">ccl_program_new_from_binary_file()</a> - Create a new program wrapper object from a file containing binary code executable on a specific device.</li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga2f8222c9eda0f702bdcea41842f9ce8c" title="Create a new program wrapper object from files containing binary code executable on the given device ...">ccl_program_new_from_binary_files()</a> - Create a new program wrapper object from files containing binary code executable on the given device list, one file per device.</li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga0d7a921139473abf0185be8fd0508932" title="Create a new program wrapper object from binary code executable on a specific device. ">ccl_program_new_from_binary()</a> - Create a new program wrapper object from binary code executable on a specific device.</li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga2746fd0de80b3fef0d9c1f811b809b37" title="Create a new program wrapper object from a list of binary code strings executable on the given device...">ccl_program_new_from_binaries()</a> - Create a new program wrapper object from a list of binary code strings executable on the given device list, one binary string per device.</li>
</ul>
<p>The <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga798de933f3f596db3c71669a5f37de85" title="Create a new program wrapper object from device built-in kernels. ">ccl_program_new_from_built_in_kernels()</a> constructor directly wraps the native OpenCL <a href="http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/clCreateProgramWithBuiltInKernels.html">clCreateProgramWithBuiltInKernels()</a> function, allowing to create programs from built-in kernels. This method is only available for platforms which support OpenCL version 1.2 or higher.</p>
<p>Like most <em>cf4ocl</em> wrapper objects, program wrapper objects follow the <a class="el" href="index.html#ug_new_destroy">new/destroy</a> rule, and should be released with the <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga3e96ea5591aaa0635ddfd24854845c4a" title="Decrements the reference count of the program wrapper object. ">ccl_program_destroy()</a> destructor.</p>
<p>The <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gab8f0b94bff812ddf51f3e2b47cde9705" title="Utility function which builds (compiles and links) a program executable from the program source or bi...">ccl_program_build()</a> and <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gaceacfa122ca71a9ad23fedcd6b236e76" title="Builds (compiles and links) a program executable from the program source or binary. ">ccl_program_build_full()</a> methods allow to build a program executable from the program source or binary. While the later directly maps the native <a href="http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/clBuildProgram.html">clBuildProgram()</a> OpenCL function, the former provides a simpler interface which will be useful in many situations.</p>
<p>Compilation and linking (which require OpenCL &gt;= 1.2) are provided by the <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gae0634933015623dfa34203eafff28acc" title="Compile a program&#39;s source code. ">ccl_program_compile()</a> and <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gaf0c902b346412e9bb366af10f5dcd7b8" title="Link a set of compiled programs and create an executable program wrapper. ">ccl_program_link()</a> functions.</p>
<p>Information about program objects can be obtained using the program module <a class="el" href="index.html#ug_getinfo">info macros</a>:</p>
<ul>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga7fd5be827f63f15ad21dbdbf7b016500" title="Macro which returns a scalar program information value. ">ccl_program_get_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gae67a06dc6f200708b4c9cf7071afdbe6" title="Macro which returns an array program information value. ">ccl_program_get_info_array()</a></li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga430ea85913a66caa1c700266871aa294" title="Get a CCLWrapperInfo program information object. ">ccl_program_get_info()</a></li>
</ul>
<p>However, program binaries cannot be retrieved using these macros. Consequently, <em>cf4ocl</em> provides a specific and straightforward API for handling them:</p>
<ul>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gaa94b70f6b25d19e4eaf3f1b87df04e87" title="Get the program binary object for the specified device. ">ccl_program_get_binary()</a> - Return the program binary object for the specified device.</li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga2e24dbfc56cd4c27b20a2e5269777d8f" title="Save the program binary code for a specified device to a file. ">ccl_program_save_binary()</a> - Save the program binary code for a specified device to a file.</li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga73327aa43261abe28c257f80cc7258ca" title="Save the program binaries for all associated devices to files, one file per device. ">ccl_program_save_all_binaries()</a> - Save the program binaries for all associated devices to files, one file per device.</li>
</ul>
<p>Program build information can be obtained using a specific set of <a class="el" href="index.html#ug_getinfo">info macros</a>:</p>
<ul>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gad0ac1d3dc4ca8fd033c5be8f682c12db" title="Macro which returns a scalar program build information value. ">ccl_program_get_build_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gaeaf9feeda0d528694e25c743556328ad" title="Macro which returns an array program build information value. ">ccl_program_get_build_info_array()</a></li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gab21d12e4d69bae379963f415a41236c9" title="Get a CCLWrapperInfo program build information object. ">ccl_program_get_build_info()</a></li>
</ul>
<p>For simple programs and kernels, the program wrapper module offers three functions, which can be used onced a program is built:</p>
<ul>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga4784ac5e69352e4425ab26e92e68e683" title="Get the kernel wrapper object for the given program kernel function. ">ccl_program_get_kernel()</a> - Get the kernel wrapper object for the given program kernel function.</li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gabdf0fff525612aeb22304560e4ea3bce" title="Enqueues a program kernel function for execution on a device. ">ccl_program_enqueue_kernel()</a> - Enqueues a program kernel function for execution on a device, accepting kernel arguments as <code>NULL</code>-terminated variable list of parameters.</li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gae454ad5e2161be6b0be2f5d786a12f0e" title="Enqueues a program kernel function for execution on a device. ">ccl_program_enqueue_kernel_v()</a> - Enqueues a program kernel function for execution on a device, accepting kernel arguments as <code>NULL</code>-terminated array of parameters.</li>
</ul>
<p>Program wrapper objects only keep one kernel wrapper instance per kernel function; as such, for a given kernel function, these methods will always use the same kernel wrapper instance (and consequently, the same OpenCL kernel object). While this will work for single-threaded host code, it will fail if the same kernel wrapper is invoked from different threads. In such cases, use the <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html">kernel wrapper module</a> API for handling kernel wrapper objects.</p>
<p>The <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gad49948bcbb49fc6dbd83928775f8cb33" title="Program wrapper class. ">CCLProgram</a>* class extends the <a class="el" href="ccl__common_8h.html#af08e755467d7fb60b52685e2c21752e0" title="Base class for wrappers which contain devices, i.e., CCLPlatform, CCLProgram and CCLContext. ">CCLDevContainer</a>* class; as such, it provides methods for handling a list of devices associated with the program:</p>
<ul>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gaf9548211f33589caf33262d28c14c981" title="Get all device wrappers in program. ">ccl_program_get_all_devices()</a></li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gaf5037e92121f144d8af2034ae7833c70" title="Get CCLDevice wrapper at given index. ">ccl_program_get_device()</a></li>
<li><a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gae7f10556b6a80935cd0b35a27c88a098" title="Return number of devices in program. ">ccl_program_get_num_devices()</a></li>
</ul>
<p><em>Example:</em></p>
<p>Kernel code:  <div class="fragment"><div class="line">__kernel <span class="keywordtype">void</span> sum(__global <span class="keyword">const</span> uint *a, __global <span class="keyword">const</span> uint *b,</div>
<div class="line">    __global uint *c, uint d, uint buf_size) {</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Get global ID. */</span></div>
<div class="line">    uint gid = get_global_id(0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Only perform sum if this workitem is within the size of the</span></div>
<div class="line"><span class="comment">     * vector. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (gid &lt; buf_size)</div>
<div class="line">        c[gid] = a[gid] + b[gid] + d;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>Host code:  <div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="test__buffer_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Wrappers. */</span></div>
<div class="line">    <a class="code" href="structccl__context.html">CCLContext</a>* ctx = NULL;</div>
<div class="line">    <a class="code" href="structccl__program.html">CCLProgram</a>* prg = NULL;</div>
<div class="line">    <a class="code" href="structccl__device.html">CCLDevice</a>* dev = NULL;</div>
<div class="line">    <a class="code" href="structccl__queue.html">CCLQueue</a>* queue = NULL;</div>
<div class="line">    <a class="code" href="structccl__buffer.html">CCLBuffer</a>* a_dev;</div>
<div class="line">    <a class="code" href="structccl__buffer.html">CCLBuffer</a>* b_dev;</div>
<div class="line">    <a class="code" href="structccl__buffer.html">CCLBuffer</a>* c_dev;</div>
<div class="line">    <a class="code" href="structccl__event.html">CCLEvent</a>* evt_exec;</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Global and local worksizes. */</span></div>
<div class="line">    <span class="keywordtype">size_t</span> gws;</div>
<div class="line">    <span class="keywordtype">size_t</span> lws;</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Error reporting object. */</span></div>
<div class="line">    GError* err = NULL;</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Create a new program from kernel source. */</span></div>
<div class="line">    prg = <a class="code" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga96ffc087b78c9f4995b19cd837407531">ccl_program_new_from_source</a>(ctx, KERNEL_SRC, &amp;err);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Build program. */</span></div>
<div class="line">    <a class="code" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gab8f0b94bff812ddf51f3e2b47cde9705">ccl_program_build</a>(prg, NULL, &amp;err);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    evt_exec = <a class="code" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gabdf0fff525612aeb22304560e4ea3bce">ccl_program_enqueue_kernel</a>(prg, KERNEL_NAME, queue, 1,</div>
<div class="line">        NULL, &amp;gws, &amp;lws, &amp;ewl, &amp;err,</div>
<div class="line">        <span class="comment">/* Kernel arguments. */</span></div>
<div class="line">        a_dev, b_dev, c_dev,</div>
<div class="line">        <a class="code" href="group___c_c_l___k_e_r_n_e_l___a_r_g.html#ga95f41500496777d0ea1e23aee566e90b">ccl_arg_priv</a>(d_host, cl_uint), <a class="code" href="group___c_c_l___k_e_r_n_e_l___a_r_g.html#ga95f41500496777d0ea1e23aee566e90b">ccl_arg_priv</a>(buf_n, cl_uint),</div>
<div class="line">        NULL);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Destroy wrappers. */</span></div>
<div class="line">    <a class="code" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga3e96ea5591aaa0635ddfd24854845c4a">ccl_program_destroy</a>(prg);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">}</div>
</div><!-- fragment --></p>
<h3><a class="anchor" id="ug_kernel"></a>
Kernel module</h3>
<p>The kernel wrapper module provides functionality for simple handling of OpenCL kernel objects. Kernel wrappers can be obtained using two approaches:</p>
<ol type="1">
<li>Using the <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga4784ac5e69352e4425ab26e92e68e683" title="Get the kernel wrapper object for the given program kernel function. ">ccl_program_get_kernel()</a> function. This function always returns the same kernel wrapper object (with the same underlying OpenCL kernel object) associated with a program. The returned object is automatically freed when the program wrapper object is destroyed; as such, client code should not call <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gab24f0ee52fc47530b86fe68ecd01e69c" title="Decrements the reference count of the kernel wrapper object. ">ccl_kernel_destroy()</a>.</li>
<li>Using the <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga1ab27c7c34dbeada0b69385d6401efd7" title="Create a new kernel wrapper object. ">ccl_kernel_new()</a> constructor. The created kernel wrapper should be released with the <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gab24f0ee52fc47530b86fe68ecd01e69c" title="Decrements the reference count of the kernel wrapper object. ">ccl_kernel_destroy()</a> function, in accordance with the <em>cf4ocl</em> <a class="el" href="index.html#ug_new_destroy">new/destroy</a> rule.</li>
</ol>
<p>While the first approach might be more convenient, it will not work properly if the same kernel function is to be handled and executed by different threads. In these cases, use the second approach to create distinct kernel wrapper instances (wrapping distinct OpenCL kernel objects) for the same kernel function, one for each thread.</p>
<p>This module offers several functions which simplify kernel execution. For example, the <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gacdf010f28f7c6f22b68a780a6fcfc59c" title="Set kernel arguments and enqueue it for execution on a device. ">ccl_kernel_set_args_and_enqueue_ndrange()</a> function can set all kernel arguments and execute the kernel in one call.</p>
<p>Information about kernel objects can be fetched using the kernel <a class="el" href="index.html#ug_getinfo">info macros</a>:</p>
<ul>
<li><a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga664c952cd4b7fa5ae4f5a3d0dfc3fbf9" title="Macro which returns a scalar kernel information value. ">ccl_kernel_get_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga2a7f5565f5a48c7329a3bb2522dcd791" title="Macro which returns an array kernel information value. ">ccl_kernel_get_info_array()</a></li>
<li><a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gac5e00f8e2e962830222e3ab902993d79" title="Get a CCLWrapperInfo kernel information object. ">ccl_kernel_get_info()</a></li>
</ul>
<p>Six additional macros are provided for getting kernel workgroup info and kernel argument info (the later is only available from OpenCL 1.2 onwards). These work in the same way as the regular info macros:</p>
<ul>
<li><a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gaec6348ff54dea33d384d84cc4fb31dce" title="Macro which returns a scalar kernel workgroup information value. ">ccl_kernel_get_workgroup_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga035fd12dd0d306ee8a10663fcc1a20e7" title="Macro which returns an array kernel workgroup information value. ">ccl_kernel_get_workgroup_info_array()</a></li>
<li><a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gaff4efa015ff6ad3a72bf7df9988eb24a" title="Get a CCLWrapperInfo kernel workgroup information object. ">ccl_kernel_get_workgroup_info()</a></li>
<li><a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga51d35990d7aeaab2e603542dd920d588" title="Macro which returns a scalar kernel argument information value. ">ccl_kernel_get_arg_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga77452264226437f1f5235061904ad995" title="Macro which returns an array kernel argument information value. ">ccl_kernel_get_arg_info_array()</a></li>
<li><a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga8ce07b4b242c5461bb6835a1981ba360" title="Get a CCLWrapperInfo kernel argument information object. ">ccl_kernel_get_arg_info()</a></li>
</ul>
<p><em>Example: getting a kernel wrapper from a program wrapper</em></p>
<div class="fragment"><div class="line"><a class="code" href="structccl__program.html">CCLProgram</a>* prg;</div>
<div class="line"><a class="code" href="structccl__kernel.html">CCLKernel</a>* krnl;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">krnl = <a class="code" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga4784ac5e69352e4425ab26e92e68e683">ccl_program_get_kernel</a>(prg, <span class="stringliteral">&quot;some_kernel&quot;</span>, NULL);</div>
</div><!-- fragment --><p><em>Example: creating a kernel wrapper</em></p>
<div class="fragment"><div class="line"><a class="code" href="structccl__program.html">CCLProgram</a>* prg;</div>
<div class="line"><a class="code" href="structccl__kernel.html">CCLKernel</a>* krnl;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">krnl = <a class="code" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga1ab27c7c34dbeada0b69385d6401efd7">ccl_kernel_new</a>(prg, <span class="stringliteral">&quot;some_kernel&quot;</span>, NULL);</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a class="code" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gab24f0ee52fc47530b86fe68ecd01e69c">ccl_kernel_destroy</a>(krnl);</div>
</div><!-- fragment --><h4><a class="anchor" id="ug_kernel_args"></a>
Kernel arguments module</h4>
<p>This module defines the <a class="el" href="ccl__kernel__arg_8h.html#a741d0e62c96de11c36d112856422e281" title="The CCLArg type is an alias for CCLWrapper type. ">CCLArg</a>* class which wraps kernel arguments. Several functions in the <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html">kernel wrapper module</a>, such as <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gaff6fc17690d0ad1517ad71c5405e4aff" title="Set all kernel arguments. ">ccl_kernel_set_args()</a> or <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gacdf010f28f7c6f22b68a780a6fcfc59c" title="Set kernel arguments and enqueue it for execution on a device. ">ccl_kernel_set_args_and_enqueue_ndrange()</a>, accept kernel arguments as parameters. <a class="el" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html#ga74a5e095bf96ac7f6ebb99bbb61a926f" title="Buffer wrapper class. ">CCLBuffer</a>*, <a class="el" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga0aac60cad56cb1a8cd89d138d8d5acd2" title="Image wrapper class. ">CCLImage</a>* and <a class="el" href="group___c_c_l___s_a_m_p_l_e_r___w_r_a_p_p_e_r.html#ga23ebcd4de2b4e4142cd62c337886c133" title="Sampler wrapper class. ">CCLSampler</a>* objects can be directly passed as global kernel arguments to these functions. However, local and private kernel arguments need to be passed using the macros provided in this module, namely <a class="el" href="group___c_c_l___k_e_r_n_e_l___a_r_g.html#gac5e64c7fa6e474e6b49c3342581fbe92" title="Defines a local kernel argument, which allocates local memory within the kernel with the specified si...">ccl_arg_local()</a> and <a class="el" href="group___c_c_l___k_e_r_n_e_l___a_r_g.html#ga95f41500496777d0ea1e23aee566e90b" title="Define a private kernel argument. ">ccl_arg_priv()</a>, respectively.</p>
<p>The <a class="el" href="group___c_c_l___k_e_r_n_e_l___a_r_g.html#ga48caa7e87067c88ad246e3ec0dd82c95" title="Use this constant to skip kernel arguments in the ccl_kernel_set_args(), ccl_kernel_set_args_v(), ccl_kernel_set_args_and_enqueue_ndrange() and ccl_kernel_set_args_and_enqueue_ndrange_v() functions. ">ccl_arg_skip</a> constant can be passed to methods which accept a variable list of ordered arguments in order to skip a specific argument.</p>
<p><em>Example:</em></p>
<p><em>Kernel code:</em> </p><div class="fragment"><div class="line">__kernel <span class="keywordtype">void</span> my_kernel(</div>
<div class="line">    __global <span class="keywordtype">int</span>* g, __local <span class="keywordtype">int</span> *l, __private <span class="keywordtype">float</span> p) {</div>
</div><!-- fragment --> <div class="fragment"><div class="line">}</div>
</div><!-- fragment --><p> <em>Host code:</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define LOC_SIZE 16</span></div>
<div class="line"><span class="preprocessor">const cl_float pi=3.1415;</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a class="code" href="structccl__program.html">CCLProgram</a>* prg;</div>
<div class="line"><a class="code" href="structccl__kernel.html">CCLKernel</a>* krnl;</div>
<div class="line"><a class="code" href="structccl__buffer.html">CCLBuffer</a>* buf;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">krnl = <a class="code" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#ga4784ac5e69352e4425ab26e92e68e683">ccl_program_get_kernel</a>(prg, <span class="stringliteral">&quot;my_kernel&quot;</span>, NULL);</div>
<div class="line"><a class="code" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gaff6fc17690d0ad1517ad71c5405e4aff">ccl_kernel_set_args</a>(krnl, buf, <a class="code" href="group___c_c_l___k_e_r_n_e_l___a_r_g.html#gac5e64c7fa6e474e6b49c3342581fbe92">ccl_arg_local</a>(LOC_SIZE, cl_int),</div>
<div class="line">    <a class="code" href="group___c_c_l___k_e_r_n_e_l___a_r_g.html#ga95f41500496777d0ea1e23aee566e90b">ccl_arg_priv</a>(pi, cl_float), NULL);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>These macros wrap the <a class="el" href="ccl__kernel__arg_8c.html#a16247fc1f7c063d98e5605a34745c087" title="Create a new kernel argument. ">ccl_arg_new()</a> function, which returns a new <a class="el" href="ccl__kernel__arg_8h.html#a741d0e62c96de11c36d112856422e281" title="The CCLArg type is an alias for CCLWrapper type. ">CCLArg</a>* object. <a class="el" href="ccl__kernel__arg_8h.html#a741d0e62c96de11c36d112856422e281" title="The CCLArg type is an alias for CCLWrapper type. ">CCLArg</a>* objects are destroyed when the kernel to which they were passed is released. For further control of argument instantiation, client code can use the <a class="el" href="group___c_c_l___k_e_r_n_e_l___a_r_g.html#gaf635349c8be9ebae1de507d3b6eded20" title="Defines a kernel argument with more control. ">ccl_arg_full()</a> macro instead of the <a class="el" href="ccl__kernel__arg_8c.html#a16247fc1f7c063d98e5605a34745c087" title="Create a new kernel argument. ">ccl_arg_new()</a> function in order to respect the <a class="el" href="index.html#ug_new_destroy">new/destroy</a> rule.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>A <a class="el" href="ccl__kernel__arg_8h.html#a741d0e62c96de11c36d112856422e281" title="The CCLArg type is an alias for CCLWrapper type. ">CCLArg</a>* object can only be passed once to a kernel. One way to guarantee this is to use the macros directly when setting the kernel arguments, as shown in the example above.</dd></dl>
<h3><a class="anchor" id="ug_event"></a>
Event module</h3>
<p>The event wrapper module provides functionality for simple handling of OpenCL event objects. Typical event wrappers are not directly created by client code. They are returned by event producing functions (such as <a class="el" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga26d4b539acd98fd9ae91711436875700" title="Write to an image or image array object from host memory. ">ccl_image_enqueue_write()</a>, which wraps the <a href="http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/clEnqueueWriteImage.html">clEnqueueWriteImage()</a> OpenCL function). As such, and in accordance with the <a class="el" href="index.html#ug_new_destroy">new/destroy</a> rule, regular event wrappers objects should not be destroyed by client code. They are automatically released when the command queue wrapper where the event took place is destroyed. User events (OpenCL &gt;= 1.1), created with the <a class="el" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html#gacc7c5873bb20a6aacf5dbde4fc54506e" title="Create a new user event. ">ccl_user_event_new()</a> constructor, are the only exception. These are special events which allow applications to enqueue commands that wait on user-controlled occurrences before the command is executed by the device. These events should be destroyed with <a class="el" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html#gaab711e342ac752fcecb3a4c9f4f4c20a" title="Decrements the reference count of the event wrapper object. ">ccl_event_destroy()</a>.</p>
<p>The <a class="el" href="group___c_c_l___e_v_e_n_t___w_a_i_t___l_i_s_t.html">event wait list section</a> provides additional information on how to use events to synchronize the execution of OpenCL commands. Events are also used by the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html">profiler module</a>, although indirectly via <a class="el" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#ga961b7c1f3a0e7bb4fef88401b9f11714" title="Command queue wrapper class. ">CCLQueue</a>* wrappers, to profile and benchmark applications.</p>
<p>Information about event objects can be fetched using the respective <a class="el" href="index.html#ug_getinfo">info macros</a>:</p>
<ul>
<li><a class="el" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html#gab8addd594f60ebdc6cb08b7a73c36a04" title="Macro which returns a scalar event information value. ">ccl_event_get_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html#gaac88b59e3581fa1aee74a2218d2a453a" title="Macro which returns an array event information value. ">ccl_event_get_info_array()</a></li>
<li><a class="el" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html#ga658e739286186e9bddd2d8ad65974cf1" title="Get a CCLWrapperInfo event information object. ">ccl_event_get_info()</a></li>
</ul>
<p>Three additional macros are provided for getting event profiling info. These work in the same way as the regular info macros:</p>
<ul>
<li><a class="el" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html#gaed13ff125e78c3026f3638ec89801ee4" title="Macro which returns a scalar event profiling information value. ">ccl_event_get_profiling_info_scalar()</a></li>
<li><a class="el" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html#gae4a80690ec702fcebc559c9db152f2fc" title="Macro which returns an array event profiling information value. ">ccl_event_get_profiling_info_array()</a></li>
<li><a class="el" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html#gabb6f0cf949e51809974f44e492965596" title="Get a CCLWrapperInfo event profiling information object. ">ccl_event_get_profiling_info()</a></li>
</ul>
<h4><a class="anchor" id="ug_event_wait_lists"></a>
Event wait lists module</h4>
<p>This module provides simple management of event wait lists. Client code must initialize <a class="el" href="group___c_c_l___e_v_e_n_t___w_a_i_t___l_i_s_t.html#gadc108d008ea7d20673d7be8c62b9563c" title="A list of event objects on which enqueued commands can wait. ">CCLEventWaitList</a> variables to <code>NULL</code>, and can reuse them between <code>ccl_*_enqueue_*()</code> function calls. No allocation and deallocation of events and event wait lists is required if populated event wait lists are consumed by <code>ccl_*_enqueue_*()</code> functions; otherwise, unused non-empty event wait lists should be freed with the <a class="el" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html#gaead434bd8bc0cc928036ae1df1d06948" title="Clears an event wait list. ">ccl_event_wait_list_clear()</a> function.</p>
<p><em>Example 1:</em></p>
<div class="fragment"><div class="line"><a class="code" href="structccl__event.html">CCLEvent</a> *evt1, *evt2, *evt3;</div>
<div class="line"><a class="code" href="group___c_c_l___e_v_e_n_t___w_a_i_t___l_i_s_t.html#gadc108d008ea7d20673d7be8c62b9563c">CCLEventWaitList</a> evt_wait_lst = NULL;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">evt1 = <a class="code" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html#ga35233c6c927a2304d81ce149a2de673c">ccl_buffer_enqueue_write</a>(cq, a_dev, CL_FALSE, 0, size, a_host, NULL, NULL);</div>
<div class="line">evt2 = <a class="code" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html#ga35233c6c927a2304d81ce149a2de673c">ccl_buffer_enqueue_write</a>(cq, b_dev, CL_FALSE, 0, size, b_host, NULL, NULL);</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a class="code" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html#gacbed387afd61bcf6a54c4eec8ae7d5f3">ccl_event_wait_list_add</a>(&amp;evt_wait_lst, evt1, evt2, NULL);</div>
<div class="line">evt3 = <a class="code" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga2ef630e6882cbf134551a1551521b4b4">ccl_kernel_enqueue_ndrange</a>(krnl, cq, dim, offset, gws, lws, &amp;evt_wait_lst, NULL);</div>
<div class="line"><a class="code" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html#gacbed387afd61bcf6a54c4eec8ae7d5f3">ccl_event_wait_list_add</a>(&amp;evt_wait_lst, evt3, NULL);</div>
<div class="line"><a class="code" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html#ga4399e6ec33872f78ece3e011f8e59ff6">ccl_buffer_enqueue_read</a>(cq, c_dev, CL_TRUE, 0, size, c_host, &amp;evt_wait_lst, NULL);</div>
</div><!-- fragment --><p><em>Example 2:</em></p>
<div class="fragment"><div class="line"><a class="code" href="structccl__event.html">CCLEvent</a> *evt = NULL;</div>
<div class="line"><a class="code" href="group___c_c_l___e_v_e_n_t___w_a_i_t___l_i_s_t.html#gadc108d008ea7d20673d7be8c62b9563c">CCLEventWaitList</a> evt_wait_lst = NULL;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">evt = <a class="code" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html#ga35233c6c927a2304d81ce149a2de673c">ccl_buffer_enqueue_write</a>(cq1, dev, CL_FALSE, 0, size, a_host, NULL, NULL);</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a class="code" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga2ef630e6882cbf134551a1551521b4b4">ccl_kernel_enqueue_ndrange</a>(krnl, cq2, dim, offset, gws, lws,</div>
<div class="line">    <a class="code" href="group___c_c_l___e_v_e_n_t___w_a_i_t___l_i_s_t.html#gabbcd8c27f903117567f8136d93c3e713">ccl_ewl</a>(&amp;evt_wait_lst, evt, NULL), NULL);</div>
</div><!-- fragment --><h2><a class="anchor" id="ug_othermodules"></a>
Other modules</h2>
<h3><a class="anchor" id="ug_devsel"></a>
Device selector module</h3>
<p>This module offers a mechanism for selecting OpenCL devices, mainly for context creation, although its functionality can be used for other purposes. The <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga3d8c995ca400c45b976f95b00481918f" title="Create a new context wrapper object selecting devices using the given set of filters. ">ccl_context_new_from_filters_full()</a> context wrapper constructor (and the <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#gae774ea8a5ce7e99d8f9de7d41f16bf2c" title="Create a new context wrapper object selecting devices using the given set of filters. ">ccl_context_new_from_filters()</a> macro) accepts a <a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga910386a6aac4f278e79b32118bd3cc14" title="A set of independent and dependent device filters. ">CCLDevSelFilters</a> object containing a set of filters. These filters define which devices can be used in the context. Instances of <a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga910386a6aac4f278e79b32118bd3cc14" title="A set of independent and dependent device filters. ">CCLDevSelFilters</a> must be initialized to NULL:</p>
 <div class="fragment"><div class="line">    <span class="comment">/* cf4ocl objects. */</span></div>
<div class="line">    <a class="code" href="structccl__context.html">CCLContext</a>* ctx;</div>
<div class="line">    <a class="code" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga910386a6aac4f278e79b32118bd3cc14">CCLDevSelFilters</a> filters = NULL;</div>
<div class="line">    <a class="code" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga7136e1d30243110d53206997773ba664">CCLDevSelDevices</a> devices;</div>
</div><!-- fragment --></p>
<p>Filters can then be added to the <a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga910386a6aac4f278e79b32118bd3cc14" title="A set of independent and dependent device filters. ">CCLDevSelFilters</a> object with the <a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga2b491844fe3ac35da89682ba6e99dddc" title="Add a dependent filter to the filter set. ">ccl_devsel_add_dep_filter()</a> and <a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga8e5a2748a5211337cc215578f4052258" title="Add an independent filter to the filter set. ">ccl_devsel_add_indep_filter()</a> functions, which add <a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r___d_e_p___f_i_l_t_e_r_s.html">dependent</a> or <a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r___i_n_d_e_p___f_i_l_t_e_r_s.html">independent</a> filters, respectively. Filters are processed in the order in which they are added. For example, lets add an independent and a dependent filter to the <a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga910386a6aac4f278e79b32118bd3cc14" title="A set of independent and dependent device filters. ">CCLDevSelFilters</a> object:</p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Add independent filter which accepts CPU devices. */</span></div>
<div class="line">    <a class="code" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga8e5a2748a5211337cc215578f4052258">ccl_devsel_add_indep_filter</a>(</div>
<div class="line">        &amp;filters, <a class="code" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r___i_n_d_e_p___f_i_l_t_e_r_s.html#ga8c54cccd7ab369745ca4af3666cd823c">ccl_devsel_indep_type_cpu</a>, NULL);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Add &quot;same platform&quot; dependent filter. This filter should always</span></div>
<div class="line"><span class="comment">     * be added (usually in last position) for context creation, because</span></div>
<div class="line"><span class="comment">     * all devices in a context must belong to the same platform. */</span></div>
<div class="line">    <a class="code" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga2b491844fe3ac35da89682ba6e99dddc">ccl_devsel_add_dep_filter</a>(&amp;filters, <a class="code" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r___d_e_p___f_i_l_t_e_r_s.html#ga35dd881443f4ff89687e0e7ca5361c57">ccl_devsel_dep_platform</a>, NULL);</div>
</div><!-- fragment --></p>
<p>At this stage, the most common use for the <a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga910386a6aac4f278e79b32118bd3cc14" title="A set of independent and dependent device filters. ">CCLDevSelFilters</a> object is to pass it to a context wrapper constructor:</p>
<p><div class="fragment"><div class="line">        <span class="comment">/* Create context wrapper, which must have at least one device. */</span></div>
<div class="line">        ctx = <a class="code" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#gae774ea8a5ce7e99d8f9de7d41f16bf2c">ccl_context_new_from_filters</a>(&amp;filters, &amp;err);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">        <span class="comment">/* Free context. */</span></div>
<div class="line">        <a class="code" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga098e2247761d601377556cd26e1e28ba">ccl_context_destroy</a>(ctx);</div>
</div><!-- fragment --></p>
<p>However, the <a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga910386a6aac4f278e79b32118bd3cc14" title="A set of independent and dependent device filters. ">CCLDevSelFilters</a> object can also be used for explicit device selection:</p>
<p><div class="fragment"><div class="line">        <span class="comment">/* Perform device selection. */</span></div>
<div class="line">        devices = <a class="code" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga801421ebd663af84292305e97bcb9503">ccl_devsel_select</a>(&amp;filters, &amp;err);</div>
</div><!-- fragment --></p>
<p>The <a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga7136e1d30243110d53206997773ba664" title="A set of device wrappers, used between filtering steps. ">CCLDevSelDevices</a> object represented by <code>devices</code> is just a <a href="https://developer.gnome.org/glib/stable/glib-Pointer-Arrays.html#GPtrArray">GLib pointer array</a>, so we have direct access to the list of device wrappers and its size. For example, lets list the filtered devices by name:</p>
<p><div class="fragment"><div class="line">        <span class="comment">/* List selected devices. */</span></div>
<div class="line">        <span class="keywordflow">if</span> (devices-&gt;len &gt; 0) {</div>
<div class="line">            printf(<span class="stringliteral">&quot;%d devices were accepted by the filters:\n&quot;</span>,</div>
<div class="line">                devices-&gt;len);</div>
<div class="line">            <span class="keywordflow">for</span> (guint i = 0; i &lt; devices-&gt;len; ++i) {</div>
<div class="line">                dev_name = <a class="code" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#ga61ad09b46b5dd633b3fe3a6df6a8ee8a">ccl_device_get_info_array</a>(</div>
<div class="line">                    devices-&gt;pdata[i], CL_DEVICE_NAME, <span class="keywordtype">char</span>*, &amp;err);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">                printf(<span class="stringliteral">&quot;\t%d - %s\n&quot;</span>, i + 1, dev_name);</div>
<div class="line">            } <span class="comment">/* For */</span></div>
<div class="line">        } <span class="comment">/* If */</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Free array object containing device wrappers. The</span></div>
<div class="line"><span class="comment">         * CCLDevSelDevices class is just another name for GPtrArray*,</span></div>
<div class="line"><span class="comment">         * which is a GLib pointer array. As such, we use the GLib</span></div>
<div class="line"><span class="comment">         * pointer array destructor to release this object. */</span></div>
<div class="line">        g_ptr_array_free(devices, TRUE);</div>
</div><!-- fragment --></p>
<p><a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga910386a6aac4f278e79b32118bd3cc14" title="A set of independent and dependent device filters. ">CCLDevSelFilters</a> objects are automatically freed and reset to <code>NULL</code> when passed to context wrapper constructors or to the <a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga801421ebd663af84292305e97bcb9503" title="Select one or more OpenCL devices based on the provided filters. ">ccl_devsel_select()</a> function.</p>
<p>See the complete example <a class="el" href="device_filter_8c-example.html">here</a>.</p>
<p>The device selector module also offers two additional helper functions which return and print a list of all OpenCL devices available in the system, respectively:</p>
<ul>
<li><a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga3ed1e24665dd022674bf15a47bdb6417" title="Returns a NULL-terminated array of strings, each one containing the name and vendor of each device in...">ccl_devsel_get_device_strings()</a></li>
<li><a class="el" href="group___c_c_l___d_e_v_i_c_e___s_e_l_e_c_t_o_r.html#ga92c309bde3d8cc13373b9892f828dc57" title="Print to stdout a device description string for each device in the system. ">ccl_devsel_print_device_strings()</a></li>
</ul>
<h3><a class="anchor" id="ug_devquery"></a>
Device query module</h3>
<p>This module facilitates the querying of OpenCL devices. It primarily supports the <a class="el" href="ccl_devinfo.html">ccl_devinfo</a> utility, but may also be of use to client code.</p>
<h3><a class="anchor" id="ug_errors"></a>
Errors module</h3>
<p>This module offers a function to convert OpenCL error codes into human-readable strings. It is widely used by other <em>cf4ocl</em> modules, but may also be useful to client code which directly uses OpenCL functions.</p>
<p><em>Example:</em></p>
<div class="fragment"><div class="line">cl_int status;</div>
<div class="line">cl_event event;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">status = clWaitForEvents(1, &amp;event);</div>
<div class="line"><span class="keywordflow">if</span> (status != CL_SUCCESS) {</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;OpenCL error %d: %s&quot;</span>, status, <a class="code" href="group___c_c_l___e_r_r_o_r_s.html#gaafd92e28f947be61efac4a390cc60c3b">ccl_err</a>(status));</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="ug_platforms"></a>
Platforms module</h3>
<p>The platforms module provides functionality for managing the OpenCL platforms available in the system. The <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m_s.html#ga816d2e6c9193497a4e5d4dd68904151c" title="Creates a new CCLPlatforms* object, which contains the list of OpenCL platforms available in the syst...">ccl_platforms_new()</a> function returns a list of platforms available in the system. The <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m_s.html#ga45907b1c3ae3a783c0d49bd900e900b8" title="Return number of OpenCL platforms found in CCLPlatforms object. ">ccl_platforms_count()</a> can be used to get the number of platforms in the list, while the <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m_s.html#gaaae2cba6bd1625e3a60293725a21af47" title="Get platform wrapper object at given index. ">ccl_platforms_get()</a> will return the <img class="formulaInl" alt="$i^{th}$" src="form_6.png"/> platform.</p>
<p><em>Example:</em></p>
 <div class="fragment"><div class="line">    <span class="comment">/* cf4ocl objects. */</span></div>
<div class="line">    <a class="code" href="structccl__platforms.html">CCLPlatforms</a>* platf_list;</div>
<div class="line">    <a class="code" href="structccl__platform.html">CCLPlatform</a>* platf;</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Other variables. */</span></div>
<div class="line">    cl_uint num_platfs;</div>
<div class="line">    GError* err = NULL;</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Get all platforms in system. */</span></div>
<div class="line">    platf_list = <a class="code" href="group___c_c_l___p_l_a_t_f_o_r_m_s.html#ga816d2e6c9193497a4e5d4dd68904151c">ccl_platforms_new</a>(&amp;err);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Get number of platforms in system. */</span></div>
<div class="line">    num_platfs = <a class="code" href="group___c_c_l___p_l_a_t_f_o_r_m_s.html#ga45907b1c3ae3a783c0d49bd900e900b8">ccl_platforms_count</a>(platf_list);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Cycle through platforms. */</span></div>
<div class="line">    <span class="keywordflow">for</span> (cl_uint i = 0; i &lt; num_platfs; ++i) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Get current platform. */</span></div>
<div class="line">        platf = <a class="code" href="group___c_c_l___p_l_a_t_f_o_r_m_s.html#gaaae2cba6bd1625e3a60293725a21af47">ccl_platforms_get</a>(platf_list, i);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    } <span class="comment">/* Cycle platforms. */</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Release platform set, which will release the underlying</span></div>
<div class="line"><span class="comment">     * platform wrappers, device wrappers and the requested info. */</span></div>
<div class="line">    <a class="code" href="group___c_c_l___p_l_a_t_f_o_r_m_s.html#gac61d379e38bdcb4fed8e5569a9887adf">ccl_platforms_destroy</a>(platf_list);</div>
</div><!-- fragment --></p>
<h3><a class="anchor" id="ug_profiling"></a>
Profiler module</h3>
<p>The profiler module provides classes and methods for profiling wrapped OpenCL events and queues. </p><dl class="section warning"><dt>Warning</dt><dd>The functions in this module are not thread-safe.</dd></dl>
<p>The profiling module offers two methods for obtaining information about the performed computations:</p>
<ol type="1">
<li>Detailed profiling of OpenCL events using the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga3920fcbeab72384c0f029933af53f4c0" title="Add a command queue wrapper for profiling. ">ccl_prof_add_queue()</a> function.</li>
<li>Simple (and optional) timming of the performed computations using the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#gab653c56fad16e7829ac0ecc36583d134" title="Starts the global profiler timer. ">ccl_prof_start()</a> and <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga6ac004634555c60e527afe9f10696423" title="Stops the global profiler timer. ">ccl_prof_stop()</a> functions. If this timming is measured it will be taken into account by the <code>ccl_prof_*_summary()</code> functions.</li>
</ol>
<p>In order to use the first method, the <code>CL_QUEUE_PROFILING_ENABLE</code> property should be specified when creating command queue wrappers with <a class="el" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#ga19d744607a66062c9c4073d483c19773" title="Create a new on-host command queue wrapper object. ">ccl_queue_new()</a>.</p>
<p>After the computations take place, all the (finished) queue wrappers are passed to the profiler using the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga3920fcbeab72384c0f029933af53f4c0" title="Add a command queue wrapper for profiling. ">ccl_prof_add_queue()</a> function. The <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga5e75d3f7775d4d0844b55c373fb1f93c" title="Determine aggregate statistics for the given profile object. ">ccl_prof_calc()</a> function can then be called to perform the required analysis.</p>
<p>At this stage, different types of profiling information become available, and can be iterated over:</p>
<ol type="1">
<li><em>Aggregate event information</em>: absolute and relative durations of all events with same name, represented by the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga752b93c1deb72352bbe55276be042bc7" title="Aggregate event info. ">CCLProfAgg</a>* class. If an event name is not set during the course of the computation, the aggregation is performed by event type, i.e., by events which represent the same command. A sequence of <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga752b93c1deb72352bbe55276be042bc7" title="Aggregate event info. ">CCLProfAgg</a>* objects can be iterated over using the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga3971a69cf6b31c4f6ab0aac5818d0770" title="Initialize an iterator for profiled aggregate event instances. ">ccl_prof_iter_agg_init()</a> and <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#gaf7923ca0bfdc7da509789f60d5367002" title="Return the next aggregate statistic instance. ">ccl_prof_iter_agg_next()</a> functions. A specific aggregate event can be obtained by name using the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga139db970b28fe31a959a853d8d926077" title="Return aggregate statistics for events with the given name. ">ccl_prof_get_agg()</a> function.</li>
<li><em>Non-aggregate event information</em>: event-specific information, represented by the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga28bf1dab6591411cdf1f9fd310f67a7c" title="Event profiling info. ">CCLProfInfo</a>* class, such as event name (or type, if no name is given), the queue the event is associated with, and submit, queued, start and end instants. A sequence of <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga28bf1dab6591411cdf1f9fd310f67a7c" title="Event profiling info. ">CCLProfInfo</a>* objects can be iterated over using the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga7674f12f78276a6e4b08c47021d5e1e0" title="Initialize an iterator for event profiling info instances. ">ccl_prof_iter_info_init()</a> and <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga802dfcf4c88884ad52acf6c083b6e9c8" title="Return the next event profiling info instance. ">ccl_prof_iter_info_next()</a> functions.</li>
<li><em>Event instants</em>: specific start and end event instants, represented by the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga73e63b83cfc79a38564e1558c633810e" title="Event instant. ">CCLProfInst</a>* class. A sequence of <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga73e63b83cfc79a38564e1558c633810e" title="Event instant. ">CCLProfInst</a>* objects can be iterated over using the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#gae844e8729f84b154e0e5ab4125ce90f7" title="Initialize an iterator for event instant instances. ">ccl_prof_iter_inst_init()</a> and <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga70117714b1bf88a2d1d78c534271c42a" title="Return the next event instant instance. ">ccl_prof_iter_inst_next()</a> functions.</li>
<li><em>Event overlaps</em>: information about event overlaps, represented by the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#gabdb69550cbe59585700a1932c2dad9f0" title="Representation of an overlap of events. ">CCLProfOverlap</a>* class. Event overlaps can only occur when more than one queue is used on the same device. A sequence of <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#gabdb69550cbe59585700a1932c2dad9f0" title="Representation of an overlap of events. ">CCLProfOverlap</a>* objects can be iterated over using the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga7ad1db5efdf519937b2f774aade0b07b" title="Initialize an iterator for overlap instances. ">ccl_prof_iter_overlap_init()</a> and <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#gaac8cf44ca7df9db7ca22a77bf4b6e9e5" title="Return the next overlap instance. ">ccl_prof_iter_overlap_next()</a> functions.</li>
</ol>
<p>While this information can be subject to different types of examination by client code, the profiler module also offers some functionality which allows for a more immediate interpretation of results:</p>
<ol type="1">
<li>A summary of the profiling analysis can be obtained or printed with the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#gaa7d37d14d71f9371121e7c30cd2dc112" title="Get a summary with the profiling info. ">ccl_prof_get_summary()</a> or <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga97f32fd83cad28fbc1d079a7d18e2066" title="Print a summary of the profiling info. ">ccl_prof_print_summary()</a> functions, respectively.</li>
<li>An exported list of <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga28bf1dab6591411cdf1f9fd310f67a7c" title="Event profiling info. ">CCLProfInfo</a>* data, namely queue name, start instant, end instant and event name, sorted by start instant, can be opened by the <a class="el" href="ccl_plot_events.html">plot events</a> script to plot a Gantt-like chart of the performed computation. Such list can be exported with the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga5442064c53f87a8d065542c03ed5dd6b" title="Export event profiling information to a given stream. ">ccl_prof_export_info()</a> or <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#gabd2a567a96fc1d02225e9af4239fadce" title="Helper function which exports profiling info to a given file, automatically opening and closing the f...">ccl_prof_export_info_file()</a> functions, using the default export options.</li>
</ol>
<p><em>Example: Conway's game of life using double-buffered images</em> (<a class="el" href="ca_8c-example.html">complete example</a>)</p>
 <div class="fragment"><div class="line">    <span class="comment">/* Wrappers for OpenCL objects. */</span></div>
<div class="line">    <a class="code" href="structccl__queue.html">CCLQueue</a>* queue_exec;</div>
<div class="line">    <a class="code" href="structccl__queue.html">CCLQueue</a>* queue_comm;</div>
<div class="line">    <a class="code" href="structccl__prof.html">CCLProf</a>* prof;</div>
<div class="line">    <span class="comment">/* Error handling object (must be NULL). */</span></div>
<div class="line">    GError* err = NULL;</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Create command queues. */</span></div>
<div class="line">    queue_exec = <a class="code" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#ga19d744607a66062c9c4073d483c19773">ccl_queue_new</a>(ctx, dev, CL_QUEUE_PROFILING_ENABLE, &amp;err);</div>
<div class="line">    queue_comm = <a class="code" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#ga19d744607a66062c9c4073d483c19773">ccl_queue_new</a>(ctx, dev, CL_QUEUE_PROFILING_ENABLE, &amp;err);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Start profiling. */</span></div>
<div class="line">    prof = <a class="code" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga6b5424a140676c5820dbd951c0fb282a">ccl_prof_new</a>();</div>
<div class="line">    <a class="code" href="group___c_c_l___p_r_o_f_i_l_e_r.html#gab653c56fad16e7829ac0ecc36583d134">ccl_prof_start</a>(prof);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Write initial state. */</span></div>
<div class="line">    <a class="code" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga26d4b539acd98fd9ae91711436875700">ccl_image_enqueue_write</a>(img1, queue_comm, CL_TRUE,</div>
<div class="line">        origin, region, 0, 0, input_image, NULL, &amp;err);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Run CA_ITERS iterations of the CA. */</span></div>
<div class="line">    <span class="keywordflow">for</span> (cl_uint i = 0; i &lt; CA_ITERS; ++i) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Read result of last iteration. On first run it is the initial</span></div>
<div class="line"><span class="comment">         * state. */</span></div>
<div class="line">        evt_comm = <a class="code" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga58ed359a08c3f017a9482e214813c8a3">ccl_image_enqueue_read</a>(img1, queue_comm, CL_FALSE,</div>
<div class="line">            origin, region, 0, 0, output_images[i], NULL, &amp;err);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">        <span class="comment">/* Execute iteration. */</span></div>
<div class="line">        evt_exec = <a class="code" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gacdf010f28f7c6f22b68a780a6fcfc59c">ccl_kernel_set_args_and_enqueue_ndrange</a>(</div>
<div class="line">            krnl, queue_exec, 2, NULL, gws, lws, NULL, &amp;err,</div>
<div class="line">            img1, img2, NULL);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Read result of last iteration. */</span></div>
<div class="line">    <a class="code" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga58ed359a08c3f017a9482e214813c8a3">ccl_image_enqueue_read</a>(img1, queue_comm, CL_TRUE,</div>
<div class="line">        origin, region, 0, 0, output_images[CA_ITERS], &amp;ewl, &amp;err);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Stop profiling timer and add queues for analysis. */</span></div>
<div class="line">    <a class="code" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga6ac004634555c60e527afe9f10696423">ccl_prof_stop</a>(prof);</div>
<div class="line">    <a class="code" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga3920fcbeab72384c0f029933af53f4c0">ccl_prof_add_queue</a>(prof, <span class="stringliteral">&quot;Comms&quot;</span>, queue_comm);</div>
<div class="line">    <a class="code" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga3920fcbeab72384c0f029933af53f4c0">ccl_prof_add_queue</a>(prof, <span class="stringliteral">&quot;Exec&quot;</span>, queue_exec);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Process profiling info. */</span></div>
<div class="line">    <a class="code" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga5e75d3f7775d4d0844b55c373fb1f93c">ccl_prof_calc</a>(prof, &amp;err);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Print profiling info. */</span></div>
<div class="line">    <a class="code" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga97f32fd83cad28fbc1d079a7d18e2066">ccl_prof_print_summary</a>(prof);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Save profiling info. */</span></div>
<div class="line">    <a class="code" href="group___c_c_l___p_r_o_f_i_l_e_r.html#gabd2a567a96fc1d02225e9af4239fadce">ccl_prof_export_info_file</a>(prof, <span class="stringliteral">&quot;prof.tsv&quot;</span>, &amp;err);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Release wrappers. */</span></div>
<div class="line">    <a class="code" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#gaa2059bbd0f34d0dbc2f618e57f283993">ccl_queue_destroy</a>(queue_comm);</div>
<div class="line">    <a class="code" href="group___c_c_l___q_u_e_u_e___w_r_a_p_p_e_r.html#gaa2059bbd0f34d0dbc2f618e57f283993">ccl_queue_destroy</a>(queue_exec);</div>
</div><!-- fragment --></p>
<p><div class="fragment"><div class="line">    <span class="comment">/* Destroy profiler. */</span></div>
<div class="line">    <a class="code" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga9b0453462582d7335c3cf09f9c2eae46">ccl_prof_destroy</a>(prof);</div>
</div><!-- fragment --></p>
<p>The output of <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html#ga97f32fd83cad28fbc1d079a7d18e2066" title="Print a summary of the profiling info. ">ccl_prof_print_summary()</a> will be something like:</p>
<pre class="fragment">   Aggregate times by event  :
     ------------------------------------------------------------------
     | Event name                     | Rel. time (%) | Abs. time (s) |
     ------------------------------------------------------------------
     | NDRANGE_KERNEL                 |       97.2742 |    3.7468e-02 |
     | READ_IMAGE                     |        2.6747 |    1.0303e-03 |
     | WRITE_IMAGE                    |        0.0511 |    1.9690e-05 |
     ------------------------------------------------------------------
                                      |         Total |    3.8518e-02 |
                                      ---------------------------------
   Event overlaps            :
     ------------------------------------------------------------------
     | Event 1                | Event2                 | Overlap (s)  |
     ------------------------------------------------------------------
     | READ_IMAGE             | NDRANGE_KERNEL         |   1.3618e-04 |
     ------------------------------------------------------------------
                              |                  Total |   1.3618e-04 |
                              -----------------------------------------
   Tot. of all events (eff.) : 3.838198e-02s
   Total ellapsed time       : 4.295200e-02s
   Time spent in device      : 89.36%
   Time spent in host        : 10.64%
</pre><p>Instead of the default command-based event names such as <code>NDRANGE_KERNEL</code>, specific names can be set with the <a class="el" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html#ga16358c06bfd01b2fa48c5476df90a310" title="Set event name for profiling purposes. ">ccl_event_set_name()</a> function. This allows to: (a) separate the aggregation of events of the same type (e.g., differentiate between the execution of two different kernels); and, (b) aggregate events of different types (e.g., aggregate reads and writes into a single "comms" event).</p>
<p>The <a class="el" href="ccl_plot_events.html">ccl_plot_events.py</a> script can be used to plot a Gantt-like chart of the events which took place in the queues. Running the following command... </p><pre class="fragment">$ python ccl_plot_events.py prof.tsv
</pre><p>...will produce the following image:</p>
<div class="image">
<img src="gantt_ca.png" alt="gantt_ca.png"/>
</div>
  <h1><a class="anchor" id="ug_utils"></a>
Using the utilities</h1>
<h2><a class="anchor" id="ug_devinfo"></a>
ccl_devinfo program</h2>
<p>The <code>ccl_devinfo</code> program prints information about the OpenCL platforms and devices available on the system. By default, only basic device information, such as type, vendor or OpenCL version, is shown, allowing the user to quickly assess what platforms and devices are available.</p>
<p>All the available device information can be shown with the <code>-a</code> or <code>--all</code> options. The <code>-c &lt;param&gt;</code> option, or its long variant, <code>--custom=&lt;param&gt;</code>, allows the user to specify a partial or complete <code>cl_device_info</code> parameter name. All matching parameters will be printed. This option can be used several times.</p>
<p>The <code>-n</code> or <code>--notfound</code> flags will force the program to shown known parameters even if the respective information is not found in the device. The <code>-l</code> flag, or its long variant <code>--list</code>, tells <code>ccl_devinfo</code> to list all known device information parameters.</p>
<p>Additional information about each listed parameter can be shown with the <code>-v</code> or <code>--verbose</code> flags.</p>
<p>The <code>ccl_devinfo</code> utility can also narrow down information to specific platforms and devices with the <code>-p</code> and <code>-d</code> options, respectively (or their long variants, <code>--platform</code> and <code>--device</code>). These options accept the platform index or the (platform-wise) device index to perform the selection.</p>
<h2><a class="anchor" id="ug_kerninfo"></a>
ccl_kerninfo program</h2>
<p>The <code>ccl_kerninfo</code> program performs static analysis of OpenCL kernels. It accepts three parameters:</p>
<ol type="1">
<li>Kernel source code</li>
<li>Kernel name</li>
<li>System-wise device index (optional)</li>
</ol>
<p>If the device index is not given, the user should then select a device from a menu.</p>
<h2><a class="anchor" id="ug_plot_events"></a>
ccl_plot_events.py script</h2>
<p>The <code><a class="el" href="ccl__plot__events_8py.html" title="Plots a Gantt-like chart of OpenCL events using the profiling info exported using the profiler module...">ccl_plot_events.py</a></code> script accepts a single parameter indicating a file containing profiling info exported using the <a class="el" href="group___c_c_l___p_r_o_f_i_l_e_r.html">profiler module</a>.</p>
<p>This script requires a <a href="https://www.python.org/">Python</a> installation, and depends on the <a href="http://matplotlib.org/">Matplotlib</a> and <a href="http://www.numpy.org/">NumPy</a> libraries.</p>
<h1><a class="anchor" id="ug_advanced"></a>
Advanced</h1>
<h2><a class="anchor" id="ug_architecture"></a>
Wrapper architecture</h2>
<p>The wrapper classes, which wrap OpenCL types, are implemented using an object-oriented (OO) approach in C. While C does not directly provide OO constructs, it is possible to implement features such as inheritance, polymorphism or encapsulation. Using this approach, <em>cf4ocl</em> is able to offer a clean and logical class system, while being available in a form (C) which can be directly or indirectly invoked from other programming languages.</p>
<p>Each <em>cf4ocl</em> wrapper class is defined by a source (.c) file and a header (.h) file. The former contains the private class properties and the method implementations, while the later defines its public API. The class body is implemented in the source file as a C <code>struct</code>; the header file provides an opaque pointer to it, which is the public side of the class from a client code perspective. Inheritance is implemented by including a member representing the parent class <code>struct</code> in the body of the child class <code>struct</code>. This requires the sharing of parent class implementations. In order to keep these opaque, the respective <code>struct</code> is defined in "private" header files which are not included in the public API. This way, instances of the child class can be cast to its parent type when required. The child class <code>struct</code> effectively extends the parent class <code>struct</code>. An example of this approach can be shown with the definitions of the abstract <a class="el" href="ccl__common_8h.html#adfe76120dcae2bab1547887f101051e7" title="Base class for all OpenCL wrappers. ">CCLWrapper</a>* class and of the concrete <a class="el" href="group___c_c_l___e_v_e_n_t___w_r_a_p_p_e_r.html#ga615bf932ba8b81cc25ce8fcbaf3006a1" title="Event wrapper class. ">CCLEvent</a>* class, which extends <a class="el" href="ccl__common_8h.html#adfe76120dcae2bab1547887f101051e7" title="Base class for all OpenCL wrappers. ">CCLWrapper</a>*:</p>
<p><em>In <code>_ccl_abstract_wrapper.h</code> (not part of public API):</em> </p><div class="fragment"><div class="line"><span class="comment">/* Base class for all OpenCL wrappers. */</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structccl__wrapper.html">ccl_wrapper</a> {</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* The wrapped OpenCL object. */</span></div>
<div class="line">    <span class="keywordtype">void</span>* cl_object;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Information about the wrapped OpenCL object. */</span></div>
<div class="line">    <a class="code" href="structccl__wrapper__info__table.html">CCLWrapperInfoTable</a>* info;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Reference count. */</span></div>
<div class="line">    <span class="keywordtype">int</span> ref_count;</div>
<div class="line"></div>
<div class="line">};</div>
</div><!-- fragment --><p><em>In <a class="el" href="ccl__common_8h.html" title="Common cf4ocl definitions. ">ccl_common.h</a>:</em></p>
<div class="fragment"><div class="line"><span class="comment">/* Event wrapper class type declaration. */</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structccl__event.html">ccl_event</a> <a class="code" href="structccl__event.html">CCLEvent</a>;</div>
</div><!-- fragment --><p><em>In <a class="el" href="ccl__event__wrapper_8c.html" title="Implementation of a wrapper class and its methods for OpenCL event objects. ">ccl_event_wrapper.c</a>:</em></p>
<div class="fragment"><div class="line"><span class="comment">/* Event wrapper class, extends CCLWrapper */</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structccl__event.html">ccl_event</a> {</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Parent wrapper object. */</span></div>
<div class="line">    <a class="code" href="structccl__wrapper.html">CCLWrapper</a> base;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Event name, for profiling purposes only. */</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* name;</div>
<div class="line"></div>
<div class="line">};</div>
</div><!-- fragment --><p>Methods are implemented as functions which accept the object on which they operate as the first parameter. When useful, function-like macros are also used as object methods, such as the case of the <a class="el" href="index.html#ug_getinfo">info macros</a>. Polymorphism is not used, as the so called "abstract" methods are just functions which provide common operations to concrete methods, named differently for each concrete class. For example, the <code>ccl_dev_container_get_device()</code> abstract method is called by the <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga7b425787d8bdd23e88ff4f8242ac94c7" title="Get CCLDevice wrapper at given index. ">ccl_context_get_device()</a>, <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#ga479d80428a613e5af69fab3cef95e6f4" title="Get CCLDevice wrapper at given index. ">ccl_platform_get_device()</a> and <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gaf5037e92121f144d8af2034ae7833c70" title="Get CCLDevice wrapper at given index. ">ccl_program_get_device()</a> concrete methods, for which it provides common functionality.</p>
<p>The <em>cf4ocl</em> class hierarchy is shown in the following inheritance diagram:</p>
<div align="center">
<img src="dot_inline_dotgraph_1.png" alt="dot_inline_dotgraph_1.png" border="0" usemap="#dot_inline_dotgraph_1.map"/>
<map name="dot_inline_dotgraph_1.map" id="dot_inline_dotgraph_1.map"><area shape="rect" id="node1" href="structccl__wrapper.html" title="CCLWrapper*" alt="" coords="6,371,109,421"/><area shape="rect" id="node2" href="structccl__dev__container.html" title="CCLDevContainer*" alt="" coords="158,114,293,163"/><area shape="rect" id="node3" href="structccl__context.html" title="CCLContext*" alt="" coords="343,5,443,54"/><area shape="rect" id="node4" href="structccl__program.html" title="CCLProgram*" alt="" coords="342,78,445,127"/><area shape="rect" id="node5" href="structccl__platform.html" title="CCLPlatform*" alt="" coords="342,151,445,201"/><area shape="rect" id="node6" href="structccl__memobj.html" title="CCLMemObj*" alt="" coords="174,225,277,274"/><area shape="rect" id="node7" href="structccl__buffer.html" title="CCLBuffer*" alt="" coords="349,225,438,274"/><area shape="rect" id="node8" href="structccl__image.html" title="CCLImage*" alt="" coords="348,298,439,347"/><area shape="rect" id="node9" href="structccl__device.html" title="CCLDevice*" alt="" coords="178,298,273,347"/><area shape="rect" id="node10" href="structccl__event.html" title="CCLEvent*" alt="" coords="181,371,269,421"/><area shape="rect" id="node11" href="structccl__kernel.html" title="CCLKernel*" alt="" coords="180,445,271,494"/><area shape="rect" id="node12" href="structccl__queue.html" title="CCLQueue*" alt="" coords="179,518,271,567"/><area shape="rect" id="node13" href="structccl__sampler.html" title="CCLSampler*" alt="" coords="174,591,277,641"/></map>
</div>
<h2><a class="anchor" id="ug_cclwrapper"></a>
The CCLWrapper base class</h2>
<p>The <a class="el" href="ccl__common_8h.html#adfe76120dcae2bab1547887f101051e7" title="Base class for all OpenCL wrappers. ">CCLWrapper</a>* base class holds several low-level responsibilities for wrapper objects:</p>
<ul>
<li>Wrapping/unwrapping of OpenCL objects and maintaining a one-to-one relationship between wrapped objects and wrapper objects</li>
<li>Low-level memory management (allocation and deallocation)</li>
<li>Reference counting</li>
<li>Information handling (i.e., handling of data returned by the several <code>clGet*Info()</code> OpenCL functions)</li>
</ul>
<p>Wrapper constructors create the OpenCL object to be wrapped, but delegate memory allocation to the special <code>ccl_&lt;class&gt;_new_wrap()</code> functions. These accept the OpenCL object, and in turn call the <code>ccl_wrapper_new()</code> function, passing it not only the object, but also the size in bytes of the wrapper to be created. The <code>ccl_wrapper_new()</code> function allocates memory for the wrapper (initializing this memory to zero), and keeps the OpenCL object (wrapping it) in the created wrapper instance. For example, the <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga1ab27c7c34dbeada0b69385d6401efd7" title="Create a new kernel wrapper object. ">ccl_kernel_new()</a> creates the <code>cl_kernel</code> object with the <a href="http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/clCreateKernel.html">clCreateKernel()</a> OpenCL function, but then relies on the <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga4ee4a73aacfc6342426c6422b90014b1" title="Get the kernel wrapper for the given OpenCL kernel. ">ccl_kernel_new_wrap()</a> function (and thus, on <code>ccl_wrapper_new()</code>) for allocation and initialization of the new <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga55709ccabc636d6afabb41dd4d9ab277" title="Kernel wrapper class. ">CCLKernel</a>* wrapper object memory.</p>
<p>The destruction of wrapper objects and respective memory deallocation is performed in a similar fashion. Each wrapper class has its own <code>ccl_&lt;class&gt;_destroy()</code> method, but this method delegates actual object release to the "abstract" <code>ccl_wrapper_unref()</code> function. This function accepts the wrapper to be destroyed, its size in bytes, and two function pointers: the first, with prototype defined by <code>ccl_wrapper_release_fields()</code>, is a wrapper specific function for releasing internal wrapper objects, which the super class has no knowledge of; the second is the OpenCL object destructor function, with prototype defined by <code>ccl_wrapper_release_cl_object()</code>. Continuing on the kernel example, the <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#gab24f0ee52fc47530b86fe68ecd01e69c" title="Decrements the reference count of the kernel wrapper object. ">ccl_kernel_destroy()</a> method delegates kernel wrapper destruction to <code>ccl_wrapper_unref()</code>, passing it the kernel wrapper object, its size (i.e. <code>sizeof(</code> <a class="el" href="group___c_c_l___k_e_r_n_e_l___w_r_a_p_p_e_r.html#ga55709ccabc636d6afabb41dd4d9ab277" title="Kernel wrapper class. ">CCLKernel</a> <code>)</code>), the "private" (static in C) <code>ccl_kernel_release_fields()</code> function for destroying kernel internal objects, and the <a href="http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/clReleaseKernel.html">clReleaseKernel()</a> OpenCL kernel destructor function.</p>
<p>As such, all <em>cf4ocl</em> wrapper objects use a common memory allocation and deallocation strategy, implemented in the <a class="el" href="ccl__common_8h.html#adfe76120dcae2bab1547887f101051e7" title="Base class for all OpenCL wrappers. ">CCLWrapper</a>* super class.</p>
<p>The <code>ccl_&lt;class&gt;_new_wrap()</code> special constructors respect the <a class="el" href="index.html#ug_new_destroy">new/destroy</a> rule. Wrappers created with their special constructor must be released with the respective <code>ccl_&lt;class&gt;_destroy()</code> function. This allows client code to create OpenCL objects directly with OpenCL functions, and then wrap the objects to take advantage of <em>cf4ocl</em> functionality and features. The OpenCL object can be retrieved from its wrapper at all times with the respective <code>ccl_&lt;class&gt;_unwrap</code> method.</p>
<p>If <code>ccl_&lt;class&gt;_new_wrap()</code> functions are passed an OpenCL object which is already wrapped, a new wrapper will not be created. Instead, the existing wrapper is returned, with its reference count increased by 1. Thus, there is always a one-to-one relationship between wrapped OpenCL objects and their respective wrappers. In reality, the <code>ccl_&lt;class&gt;_destroy()</code> functions decreases the reference count of the respective wrapper, only destroying it if the reference count reaches zero. Client code can increase and decrease the reference count of a wrapper object using the associated <code>ccl_&lt;class&gt;_ref()</code> and <code>ccl_&lt;class&gt;_unref()</code> macros. The <code>ccl_&lt;class&gt;_ref()</code> macros call the <a class="el" href="structccl__wrapper.html#a9c06d7ab3630591150b19847a8d90103" title="Increase the reference count of the wrapper object. ">ccl_wrapper_ref()</a> function, casting the wrapper to its base class (<a class="el" href="ccl__common_8h.html#adfe76120dcae2bab1547887f101051e7" title="Base class for all OpenCL wrappers. ">CCLWrapper</a>*), while the <code>ccl_&lt;class&gt;_unref()</code> macros are just aliases for the respective <code>ccl_&lt;class&gt;_destroy()</code> functions.</p>
<p>The <a class="el" href="ccl__common_8h.html#adfe76120dcae2bab1547887f101051e7" title="Base class for all OpenCL wrappers. ">CCLWrapper</a>* class maintains a static hash table which associates OpenCL objects (keys) to <em>cf4ocl</em> wrappers (values). Access to this table is thread-safe and performed by the <code>ccl_wrapper_new()</code> and <code>ccl_wrapper_unref()</code> functions.</p>
<p>The management of OpenCL object information is also handled by the <a class="el" href="ccl__common_8h.html#adfe76120dcae2bab1547887f101051e7" title="Base class for all OpenCL wrappers. ">CCLWrapper</a>* class. The <a class="el" href="structccl__wrapper.html#a80ea4470dd09f32de7dc6cb4d9af47f2" title="Get information about any wrapped OpenCL object. ">ccl_wrapper_get_info()</a> method accepts two wrapper objects, the first being the object to query; the second is an auxiliary object required by some lower-level OpenCL info functions, such <a href="http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/clGetKernelWorkGroupInfo.html">clGetKernelWorkGroupInfo()</a>, which requires a device object besides the kernel object. <a class="el" href="structccl__wrapper.html#a80ea4470dd09f32de7dc6cb4d9af47f2" title="Get information about any wrapped OpenCL object. ">ccl_wrapper_get_info()</a> also requires a pointer to a OpenCL <code>clGet*Info()</code> function (with type defined as <a class="el" href="structccl__wrapper.html#afa2d64018bc4d05763706560e876ef83" title="Generic function pointer for OpenCL clget**Info() functions used to point to ccl_wrapper_info_fp1() a...">ccl_wrapper_info_fp</a>) in order to perform the desired query. <a class="el" href="structccl__wrapper.html#a80ea4470dd09f32de7dc6cb4d9af47f2" title="Get information about any wrapped OpenCL object. ">ccl_wrapper_get_info()</a> returns a <a class="el" href="ccl__abstract__wrapper_8h.html#a1613a2eb5dac5a1287594a09c7b36c02" title="Class which represents information about a wrapped OpenCL object. ">CCLWrapperInfo</a>* object, which contains two public properties: the queried value and its size. To be useful, the value must be cast to the correct type. The <a class="el" href="structccl__wrapper.html#a25cfb99b555ae76568d16037aa933fb8" title="Get pointer to information value. ">ccl_wrapper_get_info_value()</a> and <a class="el" href="structccl__wrapper.html#a34915f67228c85d9b315e197b58afb66" title="Get information size. ">ccl_wrapper_get_info_size()</a> methods call <a class="el" href="structccl__wrapper.html#a80ea4470dd09f32de7dc6cb4d9af47f2" title="Get information about any wrapped OpenCL object. ">ccl_wrapper_get_info()</a>, but directly return the value and size of the <a class="el" href="ccl__common_8h.html#adfe76120dcae2bab1547887f101051e7" title="Base class for all OpenCL wrappers. ">CCLWrapper</a>* object, respectively.</p>
<p>The requested information is kept in the information table of the respective wrapper object. When the wrapper object is destroyed, all the information objects are also released. As such, client code does not need to worry about freeing objects returned by the <code>ccl_wrapper_get_info*()</code> methods. These also accept a <code>use_cache</code> boolean argument, which if true, causes the methods to first search for the information in the wrappers information table, in case it has already been requested; if not, they proceed with the query as normal.</p>
<p>Client code will usually use the <a class="el" href="index.html#ug_getinfo">info macros</a> of each wrapper in order to fetch information about the underlying OpenCL object. These macros expand into the <code>ccl_wrapper_get_info*()</code> methods, automatically casting objects and values to the appropriate type, selecting the correct <code>clGet*Info()</code> function for the object being queried. The cache is never used by the <a class="el" href="index.html#ug_getinfo">info macros</a>.</p>
<h2><a class="anchor" id="ug_ccldevcontainer"></a>
The CCLDevContainer class</h2>
<p>The intermediate <a class="el" href="ccl__common_8h.html#af08e755467d7fb60b52685e2c21752e0" title="Base class for wrappers which contain devices, i.e., CCLPlatform, CCLProgram and CCLContext. ">CCLDevContainer</a>* class provides functionality for managing a set of <a class="el" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#gaa18648559193d4a248b1b81e3fcc56f7" title="Device wrapper class. ">CCLDevice</a>* wrapper instances, abstracting code common to the <a class="el" href="group___c_c_l___p_l_a_t_f_o_r_m___w_r_a_p_p_e_r.html#gad5b2427c1c3565977ebf05a9536d84b8" title="Platform wrapper class. ">CCLPlatform</a>*, <a class="el" href="group___c_c_l___c_o_n_t_e_x_t___w_r_a_p_p_e_r.html#ga8bf8e21eb589f02f25064e4869c8b8df" title="Context wrapper class. ">CCLContext</a>* and <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gad49948bcbb49fc6dbd83928775f8cb33" title="Program wrapper class. ">CCLProgram</a>* classes, all of which internally keep a set of devices. The <a class="el" href="ccl__common_8h.html#af08e755467d7fb60b52685e2c21752e0" title="Base class for wrappers which contain devices, i.e., CCLPlatform, CCLProgram and CCLContext. ">CCLDevContainer</a>* class contains three "abstract" methods for accessing the associated set of <a class="el" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#gaa18648559193d4a248b1b81e3fcc56f7" title="Device wrapper class. ">CCLDevice</a>* wrappers, namely:</p>
<ul>
<li><code>ccl_dev_container_get_all_devices()</code> : get all <a class="el" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#gaa18648559193d4a248b1b81e3fcc56f7" title="Device wrapper class. ">CCLDevice</a>* wrappers in device container object.</li>
<li><code>ccl_dev_container_get_device()</code> : get <a class="el" href="group___c_c_l___d_e_v_i_c_e___w_r_a_p_p_e_r.html#gaa18648559193d4a248b1b81e3fcc56f7" title="Device wrapper class. ">CCLDevice</a>* wrapper at given index.</li>
<li><code>ccl_dev_container_get_num_devices()</code> : return number of devices in device container object.</li>
</ul>
<p>Concrete wrapper implementations rely on this functionality, which is exposed to client code via specific methods methods, e.g. in the case of <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gad49948bcbb49fc6dbd83928775f8cb33" title="Program wrapper class. ">CCLProgram</a>* objects, these are <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gaf9548211f33589caf33262d28c14c981" title="Get all device wrappers in program. ">ccl_program_get_all_devices()</a>, <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gaf5037e92121f144d8af2034ae7833c70" title="Get CCLDevice wrapper at given index. ">ccl_program_get_device()</a> and <a class="el" href="group___c_c_l___p_r_o_g_r_a_m___w_r_a_p_p_e_r.html#gae7f10556b6a80935cd0b35a27c88a098" title="Return number of devices in program. ">ccl_program_get_num_devices()</a>, respectively.</p>
<h2><a class="anchor" id="ug_cclmemobj"></a>
The CCLMemObj class</h2>
<p>The relationship between the <a class="el" href="group___c_c_l___m_e_m_o_b_j___w_r_a_p_p_e_r.html#gaaad489261449960e89631f7e1cb8706d" title="Base class for memory object wrappers, i.e., CCLBuffer and CCLImage. ">CCLMemObj</a>* class and the <a class="el" href="group___c_c_l___b_u_f_f_e_r___w_r_a_p_p_e_r.html#ga74a5e095bf96ac7f6ebb99bbb61a926f" title="Buffer wrapper class. ">CCLBuffer</a>* and <a class="el" href="group___c_c_l___i_m_a_g_e___w_r_a_p_p_e_r.html#ga0aac60cad56cb1a8cd89d138d8d5acd2" title="Image wrapper class. ">CCLImage</a>* classes follows that of the respective <a href="http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/classDiagram.html">OpenCL types</a>. In other words, both OpenCL images and buffers are memory objects with common functionality, and <em>cf4ocl</em> directly maps this relationship with the respective wrappers. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jan 13 2015 22:42:20 for cf4ocl (C Framework for OpenCL) by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
